* Оператор строгого равенства (===) проверяет, равны ли два его операнда, возвращая булевский результат. В отличие от оператора равенства, оператор строгого равенства всегда считает операнды разных типов разными.

Оператор сложения с присваиванием (+=) добавляет значение правого операнда к переменной и присваивает переменной результат. Типы двух операндов определяют поведение оператора сложения с присваиванием. Добавление или конкатенация возможны.

Булевая логика
==============

* Логиеские операторы - обычно используются с булевыми (логическими) значениями; при этом возвращаемое ими значение также является булевым.

&& (и)
------

! Если есть false, то всегда возвращает false => Возвращает операнд expr1, если он может быть преобразован в false; в противном случае возвращает операнд expr2.

var a1 =  true && true;     // t && t возвращает true
var a2 =  true && false;    // t && f возвращает false
var a3 = false && true;     // f && t возвращает false
var a4 = false && (3 == 4); // f && f возвращает false
var a5 = "Cat" && "Dog";    // t && t возвращает Dog
var a6 = false && "Cat";    // f && t возвращает false
var a7 = "Cat" && false;    // t && f возвращает false

|| (или)
--------

! Если есть true, то всегда возвращает true => Возвращает операнд expr1, если он может быть преобразован в true; в противном случае возвращает операнд expr2.

var o1 =  true || true;     // t || t возвращает true
var o2 = false || true;     // f || t возвращает true
var o3 =  true || false;    // t || f возвращает true
var o4 = false || (3 == 4); // f || f возвращает false
var o5 = "Cat" || "Dog";    // t || t возвращает Cat
var o6 = false || "Cat";    // f || t возвращает Cat
var o7 = "Cat" || false;    // t || f возвращает Cat

Логическое НЕ (!expr)
------------

! Обозначает НЕ

var n1 = !true;  // !t возвращает false
var n2 = !false; // !f возвращает true
var n3 = !"Cat"; // !t возвращает false

Функции
========

* Чтобы упростить некоторые куски кода.

function calculateL(penis) {
    return 2021 + penis
}

console.log(calculateL(152)) //Вот тут в скобках, где 152, можно подставить любую хуйню. 

В консоли высветиться 2173. По сути мы можем высчитывать какое выражение, меняя одну переменную. 

Можно писать несколько сторочек подряд:

console.log(calculateL(152))
console.log(calculateL(13))
console.log(calculateL(7895))

Ещё один пример:

function calculateL(penis) {
    return 2021 + penis
}

function calculateSize(penis, manName) {
    const bigPenis = calculateL(penis)

    console.log(`У ` + manName + ` длина хуя ` + bigPenis + ` см.`)
}

calculateSize (150, `Саши`)

Вышло "У Саши длина хуя 2171 см."

!Не надо забывать расставлять пробелы в кавычках текста, он сам их не ставит. 

В примере выше мы подставили функцию из предыдущего, и запустили её в констоль логе вместе с этой. 

Мы можем также вводить в function конструкции с if (про них написано в бумажном блокноте).

Массивы
=======

* Массивы являются спископодобными объектами, чьи прототипы содержат методы для операций обхода и изменения массива. Ни размер JavaScript-массива, ни типы его элементов не являются фиксированными.

const N = [156, 111, 5050, 62158] - Массив указывается в квадратных скобках
console.log(N) - в консоль выводится массив в таком виде:

(4) [156, 111, 5050, 62158]
0: 156
1: 111
2: 5050
3: 62158
length: 4
[[Prototype]]: Array(0)

Как менять элементы в массиве?

N [1] = `сотка`

В консоли выйдет: [156, 'сотка', 5050, 62158]

* (Название массива).length - говорит сколько элементов внутри массива. Это тоже вводить в консоль логе. Пр: console.log(N.length)

Как сложить новый элемент в конец массива?

N [N.length] = 121
console.log(N) => [156, 'сотка', 5050, 62158, 121]

var arr = ['первый элемент', 'второй элемент', 'последний элемент'];
console.log(arr[0]);              // напечатает 'первый элемент'
console.log(arr[1]);              // напечатает 'второй элемент'
console.log(arr[arr.length - 1]); // напечатает 'последний элемент'

Объекты
=======

// Внутри объекта находятся СВОЙСТВА

// В объект мы группируем определённое количество значений. Если в массиве мы создаём группу, то в объекте абсолютно разные структуры.

// !Правильнее всего создавать объекты через фигурные скобки.

const L = {
    *значения для каких-либо данных*
    *Я сама решаю, какими данными заполнять объект*
}

Пример:

const suka = {
    Name: `Vuka`,
    Status: `Soska`,
    Age: 22,
    greet: function () { // greet - метод, потому что находится внутри const
        console.log (`Вика - соска нереалка`)
    } // - Вот тут мы вывели функцию: отобразить в консоли эту фразу, функция запускается, если есть команда greet.
}

console.log (suka.Name) или console.log (suka [`Name`]) => Vuka // Выводим значение конкретного свойства
suka.greet() => Вика - соска нереалка

// !Не забывать писать текст в кавычках ``.

// !Между значениями ставятся запятые.

Объекты. Продвинуто
===================

// Объекты не итерируемые
// Во внутрь объектов мы можем помещать булевые значения, массивы и функции.

const suka = {
    Name: `Vuka`,
    Status: `Soska`,
    Age: 22,
    Hobby: [`стихи`, `граффити`, `фильмы`],
    IsSexy: true,
    [`key_` + (1 + 3)]: `заебись`// Мы можем записывать названия значений в разных форматах, например в формате строки. Выйдет key_4:"заебись"
    greet () { // Можно не писать function, а просто оставить скобочки
        console.log (`Вика - соска нереалка`)
    } 
}

// Мы можем менять значения внутри объекта

suka.Age++ // В общем описании будет Age: 23

suka.Hobby.push (`баскетбол`) // Добавить единицу в массив. Получится: Hobby: (4) ['стихи', 'граффити', 'фильмы', 'баскетбол']. 

delete suka[`key_4`] // Удалить значение из объекта

Деструктуризация
----------------

// Мы выводим значения внутри объекта в отельные переменные

const {Hobby, Status} = suka // Для каждой еденицы создаётся своя переменная

const {Hobby: Weekend = 10, Status} = suka // Через двоеточие мы можем поменять название переменной, а также ввести значение по умолчанию через знак равно. Последнее при условии, если у единицы внутри объекта значение underfind.

// По-другому это можно записать так:

const Hobby = suka.Hobby
const Status = suka.Status

console.log (Hobby, Status)

Цикл for in и метод Object.keys
-------------------------------

// Цикл for...in проходит через перечисляемые свойства объекта. Он пройдёт по каждому отдельному элементу.

// Опасен, потому что он пробегается не только по ключам объекта, но и заглядывает в его прототип. Чтобы этого избежать нужно написать "проверку".

//for (variable in object) {...
//}
//variable - Другое (очередное) имя свойства назначается переменной на каждой итерации.
// object - Объект, по чьим свойствам мы проходим

for (let key1 in suka) {
    console.log('key:', key1) // В консоль будут выведены свойства объекта в виде строк
}

for (let key1 in suka) { // Вместо key1 может быть любое название
      console.log('key:', key1) // Выводим названия в виде строк 
      console.log('value:', suka[key1]) // Выводим значения свойств
    }


for (let key1 in suka) { // Вместо key1 может быть любое название
    if (suka.hasOwnProperty(key1)) { // Проверка. Метод hasOwnProperty() возвращает логическое значение, указывающее, содержит ли объект указанное свойство. 
    // Т.е. объект suka содержит своё собственное свойство, к-е не содержится в прототипе. Имя этого свойства key1.
      console.log('key:', key1)
      console.log('value:', suka[key1])
    }
}

// Альтернативный способ написать выражение выше объекта

const N = Object.keys (suka) // Метод Object.keys возвращает массив строковых элементов, соответствующих именам перечисляемых свойств, найденных непосредственно в самом объекте. Порядок свойств такой же, как и при ручном перечислении свойств в объекте через цикл.
    
N.forEach((Lol) => { // Тут используем callback функцию
    // Метод forEach() выполняет указанную функцию один раз для каждого элемента в массиве.
    console.log('key:', Lol)  
    console.log('value:', suka[Lol])
}); 

// Можно обойтись без переменной Object.keys(suka).forEach((Lol) => ...

// Результат:

//    key: Name
//    value: Vuka
//    key: Status
//    value: Soska
//    key: Age
//    value: 22
//    key: Hobby
//    value: undefined
//    key: IsSexy
//    value: true
//    key: key_4
//    value: заебись
//    key: greet
//    value: ƒ greet () { 
//       console.log (`Вика - соска нереалка`)
//    }

Контекст
--------

const suka = {
    Name: `Vuka`,
    Status: `Soska`,
    Age: 22,
    Hobby: [`стихи`, `граффити`, `фильмы`],
    IsSexy: true,
    info () { // Выводит сообщения, содержащие некоторую информацию, в Веб-консоль. 
        console.info (`Меня зовут`, this.Name) // this можно использовать вместо suka = универсальное название объекта. 
    }
}

// Метод bind привязывает новый контекст, который мы сами выберем. Метод bind возвращает новую функцию.

const logger = {
    keys () {  //Мы можем использовать метод keys, чтобы выводить в консоль вообще любой объект.
        // У метода может быть любое название. Мы сами придумываем метод.
        console.log (Object.keys (this))
    }
}

const F = logger.keys.bind (suka) // Метод bind возвращает новую функцию, поэтому мы вводим константу.
F () // F, чтобы вывести в console.log

// В console.log будет ['Name', 'Status', 'Age', 'Hobby', 'IsSexy', 'info']

// Мы пользуемся методом keys объекта logger, к-й знает про this, но ничего не знает про suka. Мы говорим, что в данном случае this, будет тем объектом, который мы задали.

// Альтернатива:

// Метод call такой же как и bind, но он просто вызывает значения и не создаёт функцию.

logger.keys.call (suka) // В console.log будет ['Name', 'Status', 'Age', 'Hobby', 'IsSexy', 'info']

const logger = {
    keysPlusValues () {  
        console.log('key:', this)  
        console.log('value:', this[])
    }
}

logger.keysPlusValues.call (suka)

// Как вывести ещё и значения свойств

const logger = {
    keysPlusValues ($) {  
        Object.keys (this).forEach(key => { // key может называться любым именем
            console.log (`"${key}": ${this[key]}`)    
        }
        )
    }
}

logger.keysPlusValues.call(suka)

// "Name": Vuka
// "Status": Soska
// "Age": 22
// "Hobby": стихи,граффити,фильмы
// "IsSexy": true
// "info": info () {  
//        console.info (`Меня зовут`, this.Name)
//    }

// Нельзя использовать function в примере выше, т.к. он создаёт другой контекст, вместо function создаём =>. Стрелочные функции не создают свой собственный контекст. 

//Условия внутри объектов

const logger = {
 
    Conditions (top, betwwen, end) {
        if (top) {
            console.log ('------- Start -------')
        }
        Object.keys (this).forEach((key, index, array) => { // key может называться любым именем
            console.log (`"${key}": ${this[key]}`)  
            if (betwwen && index !== array.length - 1) { // Тут мы задаем как не выводить условие в конце. мы пишем, что индескс не равен -1.
                console.log ('--------------')
            }
        }
        )
        if (end) {
            console.log('------- End -------')
          }
    }
}

logger.Conditions.call (suka)

Числа
=====

num = тупо число                         //Численный тип integer

float = число с десятыми, сотыми и т.д.  //Численный тип float

pow = возведённое в степень число. Пр: 10е3 => 10000 (т.е. 10 в 3 степени)

Константы
---------

В интструментах разработчика в консоли в гугле мы можем вводить Number. и выбирать различные значения.

Например, Number.MAX_SAFE_INTEGER 
9007199254740991

Number.MAX_SAFE_INTEGER - максимальное безопасное целочисленное значение в JavaScript.

MAХ_VALUE 1.7976931348623157e+30 - максимально возможное нецелое число, к-м JS может оперировать 

MIN_VALUE 5e-324 - минимально возможное нецелое число, к-м JS может оперировать 

POSITIVE_INFINITY Infinity - константанта, которая обозначает бесконечность.

NEGATIVE_INFINITY -Infinity - позитивная и негативная бесконечности как в мат анализе

* Как получить значение бесконечности?

1/0 или 2/0 => Indefinity 

Numer.NaN
---------

NaN - Not a number

console.log (typeof NaN) => Numer

!НаН появляется тогда, когда мы делим то, что нельзя делить. Например, число делим на свойство и т.д..

Пр: 

const weird = 2 / underfind
console.log (weird) => NaN

Функция isNaN — проверить, является ли конструкция NaNом.

console.log (isNaN (weird)) => true 

IsFinite
--------

* Передаёт конечно ли число.

console.log (Number.IsFinite (42)) => true // 42 конечно? Да
console.log (Number.IsFinite (Indefinity)) => false // Бесконечность конечна? Нет

parseInt и parseFloat
---------------------

* Преобразует строчку в число 

Пр:

const N = `40`

console.log (N + 2) => 402 (строчка)
console.log (Number.parseInt (N) + 2) => 42 (число)
console.log (parseInt (N) + 2) => 42 (число)

Number.parseInt (N) всё равно, что +N => плюс может также переводить строчку в число

! parseInt не работает с десятичными составляющими числа, т.е. `40,42` он преобразует в 40

! parseFloat - преобразует числа с десятичными. Действует также как и parseInt

Особенности JS
--------------

console.log (0.4 + 0.2) => 0.6000000000000001

console.log ((0.4 + 0.2).toFixed (1)) => 0.6 // Свойство toFixed тупо обрезает знаки после запятой, но число превращается в строчку

=> Как превратить строчку в число? Используем parseFloat 

* parseFloat потому что числа десятичные, были бы целые был бы parseInt.

console.log (parseFloat ((0.4 + 0.2).toFixed (1))) => 0.6 (число) // Не надо забывать брать в скобочки

console.log (+((0.4 + 0.2).toFixed(2))) => 0.6

BigInt
======

* отдельный тип данных, который позволяет оперировать числами больше, чем MAX_SAFE_INTEGER 

MAX_SAFE_INTEGER = 9007199254740991

Пример:

console.log (typeof 9007199254740991000000) => number

console.log (typeof 9007199254740991000000n) => bigint

! bigint входит в операции только друг с другом. Пример: 

console.log (9007199254740991000000n - 900719925474099100n) => 9006298534815516900900n

console.log (10n - 4) // Ошибка, т.к. это разные типы данных

console.log (parseInt (10n) - 4)  => 6 // parseInt преобразует 10n в простое число

console.log (10n - BigInt (4)) => 6n //  BigInt преобразует четвёрку в нужный тип данных

! Мы не можем оперировать с десятичными, так как int это INTEGER.

console.log (5n / 2n) => 2n // Целое число, т.к. инт не работает с десятичными

Math
====

* Работает с математическими значениями.

console.log (Math.E) => 2.718281828459045

console.log (Math.PI) => 3.141592653589793

Math.sqrt // Корень из ...

console.log (Math.sqrt (100)) => 10

Math.pow // Возвести в степень

console.log (Math.pow (5, 5)) => 3125

Math.abs // возвращает абсолютное значение числа

Math.abs('-1');     // 1
Math.abs(-2);       // 2
Math.abs(null);     // 0
Math.abs('');       // 0
Math.abs([]);       // 0
Math.abs([2]);      // 2
Math.abs([1,2]);    // NaN
Math.abs({});       // NaN
Math.abs('string'); // NaN
Math.abs();         // NaN

Math.max // Выводит максимальное значение из списка чисел 
Math.min // Выводит минимальное значение из списка чисел 

console.log (Math.max (101, 156, 8, 856)) => 856

console.log (Math.min (101, 156, 8, 856)) => 8

console.log (Math.floor(10.6)) => 10 // Округляет в меньшую сторону

console.log (Math.ceil(10.2)) => 11 // Округляет в большую сторону

console.log (Math.round(10.2)) => 10 // Возвращает к ближайшему целому 

console.log (Math.trunc(10.2)) => 10 // возвращает целую часть числа путём удаления всех дробных знаков

console.log (Math.random ()) => // Выдаёт рандомное число

Пример того как можно сократить диапазон random: 

function Nuka(max, min) {
    return Math.round (Math.random() * (max - min) + 1)
}

console.log (Nuka(110, 10))

Строки
======

const Name = `Eва`
const films = 15

const porn = `Моя любимая порноактриса ` + Name + ` снялась в ` + films + ` фильмах.`

const porn1 = `Моя любимая порноактриса ${Name} снялась в ${films} фильмах.`

Фразы выше идентичны и выходят в консоли одинаково. Чтобы не ставить стомильонов плюсов используют ${}. 
В скобки можно записать функции (function), переменные, неравенства и т.д.

Методы
-------

const Frase = `Округляет в меньшую сторону.`

console.log (Frase.length) => 27 // Показывает коичество знаков с пробелами

console.log (Frase.toUpperCase()) => ОКРУГЛЯЕТ В МЕНЬШУЮ СТОРОНУ // Пишет текст капсом

console.log (Frase.toLowerCase()) => округляет в меньшую сторону // Пишет только маленькими буквами

console.log (Frase.charAt(7)) => е // Возвращает 7 знак во фразе. Ноль перове число и тоже считается.

console.log (Frase.indexOf(мен)) => 12 // Присутсвует ли там этот элемент. Если да, то выводит с какого индекса он начинается (с какой буквы). Если нет, то выводит -1.

console.log (Frase.startsWith(`Окр`)) => true // Начинается ли с этого выражения фраза

сonsole.log (Frase.endsWith(`ону.`)) => true //По аналогии, только про конец 

сonsole.log (Frase.repeat (4)) // Повторяет фразу несколько раз

'название переменной'.trim () // помогает убрать пробелы в выражении

trimLeft // Помогает убрать пробелы слева

trimRight // Помогает убрать пробелв

conteins // Содержится ли данное слово/выр-е в строке

Функции
=======

* Функция может принимать в себя несколько параметров

* Функции в JS являются объектами. Подробно это можно увидеть с помощью команды console.dir ().

Function Declaration
--------------------

function Vuka(Name) {
    console.log (`Мой любимый мем`, Name)
}

Vuka(`Лягушка`)

* Мы можем вызывать функцию когда угодно, т.е. например, сначала написать Вука, а затем уже описать фунцию. То есть создать функцию после. С Function Expression так желать нельзя.

Function Expression
--------------------

* Когда мы складываем функцию в переменную, это называется Function Expression.

const Love = function Vuka(Name) {
    console.log (`Мой любимый мем`, Name)
}

Love (`Лягушка`)

* Функция может быть как безымянная, так и с имененем  

Анонимные функции
=================

let time = 10

setInterval ( function () {
    console.log(++time)
}, 1000) // 1000 - количество мили

=> В консоль выводится значение 10 увеличенное на 1 (11, 12, 13) каждую тясячу милисекунд (секунду)

* clearInterval() отменяет повторяющееся по времени действие, которое было ранее установлено вызовом setInterval(). Если предоставленный параметр
не идентифицирует ранее установленное действие, этот метод ничего не делает.

let time = 10

const TimeAfterTime = setInterval ( function () {
    if (time === 15) {
        clearInterval(TimeAfterTime)
    } else {
        console.log(++time)
    }
}, 1000) 

=>  В консоли будет 11, 12, 13, 14, 15. Функция выше говорит, что переменная будет прибавлять по одному каждую секунду, пока не достигнет 15. 

setTimeout / clearTimeout // Вызов функции или выполнение фрагмента кода после указанной задержки и отмена её.

Стрелочные функции
==================

! Стрелочные, потому что там присутствует такая стрелочка =>.

const Love = function Vuka(Name) {
    console.log (`Мой любимый мем`, Name)
}

Love (`Лягушка`) // Мой любимый мем Лягушка

const arrow = (Name) => {
    console.log (`Мой любимый мем`, Name)
}

arrow(`Пизда`) // Мой любимый мем Пизда

* Оба выражения выше абсолютно идентичны, т.е. можно слово function заменить тупо на стрелочку.

Как ещё можно сократить?

const arrow2 = Name =>  console.log (`Мой любимый мем`, Name)

arrow(`Пизда`) // Мой любимый мем Пизда. Без скобок пишем, потому что переменная всего одна.

const Size = Num => {
    return Num ** 2
}

или

const Size = Num => return Num ** 2

console.log(Size (2)) // В консоли выйдет 4. Суть ф-ции: возводить конкретное число во вторую степень.

Параметры по умолчанию
======================

const LoL = (a, b) => a + b 

console.log(LoL (4, 15)) // 19

console.log(LoL (4)) // NaN

const LoL1 = (a, b = 15) => a + b 

console.log(LoL1 (4))

Можно и так:

const LoL3 = (a = 150, b = a * 2) => a + b

console.log(LoL3 ()) // 450

function Love(...all) {
    let U = 0
    for (let num of all) {
        U += num
    }
    return U
}

const U2 = Love (1, 52, 10, 12)

console.log(U2) // Есть переменная Ю равная нулю. Команда поссчитать сумму всех. Сумма всех прибавить переменную Ю. Вернуть переменную Ю. Через константу Ю2 выводятся числа, которые будут складываться в функции. 

Замыкания
=========

* Используются для создания приватных переменных

function Love (sex) {
    return function (LGBT) {
        console.log (sex + LGBT)
    }
}

const life = Love (`Навсегда`)
console.log (life(`любить`)) => Навсегдалюбить

То есть благодаря константе переменная "секс" становится по умолчанию "Навсегда", а другую переменную мы можем менять.

Массивы Продвинуто
==================

* Массив это объект

* В массивах могут содержаться строки, булевые значения и числа

const Banana = ['яблоко', 'морковь', 'редька', `репа`, true, 151];

* Можно создавать массив через конструкцию new Array ()

* Прототипы - это набор взаимосвязанных объектов, благодаря которым мы можем добавить новый функционал.

`название переменной (объекта)`.push () // Добавить в конец массива новый элемент. 

* .push метод, потому что мы вызывем его у конкретного объекта

`название переменной (объекта)`.unshift () // Добавить в начало массива новый элемент.

Пример:

const Banana = ['яблоко', 'морковь', 'редька', `репа`, true, 151];

Banana.push(1523)
Banana.unshift(`мандрагора`)

console.log(Banana) => ['мандрагора', 'яблоко', 'морковь', 'редька', 'репа', true, 151, 1523]

`название переменной (объекта)`.shift (сюда можно не писать ничего) // Убрать элемент из начала массива

`название переменной (объекта)`.pop (сюда можно не писать ничего) // Убрать элемент из конца массива

`название переменной (объекта)`.reverse (сюда можно не писать ничего) // Переворачивает массив, т.е. первое становится последним и наоборот: [151, true, 'репа', 'редька', 'морковь', 'яблоко']

Задача 1: Написать фразу наоборот
---------------------------------

const text = `Убрать элемент из начала массива`

const text2 = text.split (``).reverse().join(``)

console.log(text2) => ависсам алачан зи тнемелэ ьтарбУ

Пояснение:

`название переменной (объекта)`.split // Переводим что-то в массив. Счёт элементов (индексов) начинется с нуля. 

const text2 = text.split () // Если скобки пустые, то массив будет состоять из всех букв этой строчки.

const text2 = text.split (`из`) // Убирает из фразы "из" и делит её на два элемента: (2) ['Убрать элемент ', ' начала массива']

reverse() // Переворачивает фразу

join(``) // Объединяет элементы массива в строчку - по умолчанию ч/з запятую, но тут мы заменили на ``, поэтому будет пробел

Как изменить один элемент массива?
----------------------------------

const Banana = ['яблоко', 'морковь', 'редька', `репа`, true, 151]

const index = Banana.indexOf(`редька`) // Выделяем элемент, узнаем его индекс

Banana[index] = `potato` // Заменяем его 

console.log(Banana)

=> ['яблоко', 'морковь', 'potato', 'репа', true, 151]

includes
--------

* метод, который покажет включает ли массив в себя тот или иной объект

const Banana = ['яблоко', 'морковь', 'редька', `репа`, true, 151]

console.log(Banana.includes ('морковь')) // true

.findIndex
----------

const actress = [
    {name: `Eva`, tits: 3},
    {name: `Alisa`, tits: 5},
    {name: `Kristina`, tits: 1},
]

const index1 = actress.findIndex (function (person) {
    console.log(person)
})

// {name: 'Eva', tits: 3}
// {name: 'Alisa', tits: 5}
// {name: 'Kristina', tits: 1} // .findIndex циклами совершает итерации

Метод .map
---------

// Преобразование данных.

// Метод map возвращает в консольлоге новый массив. С помощью него мы можем изменять объекты массива, не меняя его, потому что создаеётся новый массив. 

const Banana = ['яблоко', 'морковь', 'редька', `репа`]

const bigFriuts = Banana.map(fruit => { // Необходимо создать новую переменную
    return fruit.toUpperCase()
})

console.log(bigFriuts) // ['ЯБЛОКО', 'МОРКОВЬ', 'РЕДЬКА', 'РЕПА']

// Возвести все числа массива во вторую степень:

const Banana1 = [150, 56, 11, 10]

const bigFriuts1 = Banana1.map(fruit1 => fruit1 ** 2)

console.log(bigFriuts1) // [22500, 3136, 121, 100]

// Как можно все сделать красивее?

const fib = [1, 1, 2, 3, 5, 8, 13]

const pow2 = num => num ** 2
const sqrt = num => Math.sqrt(num)

const pow2Fib = fib.map(pow2).map(Math.sqrt) // Мы ввели и вывели числа из квадратного корян
console.log(pow2Fib)

Метод .filter
-------------

* Как и map, возвращает новый массив, где данные изменены согласно опр-м условиям.

const Banana1 = [150, 56, 11, 15, 110, 1]

const bigFriuts1 = Banana1.map(fruit1 => fruit1 ** 2)

const FiltrBigFriuts1 = Banana1.filter(BigFriut => BigFriut > 100) //Вводим новую функцию, с помощью которой задаём условие. Тут ретёрн не по умолчанию, поэтому  не надо писать.

// !Необходимо обязательно вводить новую переменную, иначе не будет прведена фильрация

console.log(FiltrBigFriuts1) // [150, 110]

Как найти конкретного человека?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

const index1 = actress.findIndex (function (person) { // Тут ищем индекс объекта
})
    return person.tits === 3 

console.log(index1) // Выйдет 0, потому что у {name: `Eva`, tits: 3} нулевой индекс в массиве

const index2 = actress.find (function (person) { // Тут просто ищем объект
    return person.tits === 3 
})

console.log(index2) // Выйдет {name: 'Eva', tits: 3}. 

Как записать действие выше короче?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

const index2 = actress.find (person => person.tits === 3)
console.log(index2) // Вместо функции стрелочка. Слово ретёрн не нужно, потому что выражение однострочное.

Как реализовать поиск конкретного объекта через цикл?
----------------------------------------------------

// Циклы - простой способ сделать какое-то действие несколько раз. 

// Цикл for повторяет действия, пока не произойдёт какое-либо специальное событие завершения цикла. Оператор for в JavaScript аналогичен оператору for в Java и C. Объявление оператора for выглядит следующим образом:

// for ([начало]; [условие]; [шаг]) выражения

const actress = [
    {name: `Eva`, tits: 3},
    {name: `Alisa`, tits: 5},
    {name: `Kristina`, tits: 1},
]

for (const person of actress) {
    console.log(person)
}
// В косоли:
// {name: 'Eva', tits: 3}
// {name: 'Alisa', tits: 5}
// {name: 'Kristina', tits: 1}

let SizeTits
for (const person of actress) {
    if (person.tits === 3) {
        SizeTits = person
    }
}

console.log(SizeTits) // {name: 'Eva', tits: 3}

Метод .reduce
-------------

// Метод reduce() применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.

// Суммирует данные в массиве.
// Первым параметром он принимает в себя функцию, а вторым значение от которого будем считать.
// Функция примает в себя аккумулятор (acc), который будет обновляться при каждой итерации в массиве, и элемент по которому будет проходить итерация => ВСЕГО ДВА ЭЛЕМ_ТА ВНУТРИ Ф-ЦИИ

const actress = [
    {name: `Eva`, royalty: 4500},
    {name: `Alisa`, royalty: 5180},
    {name: `Kristina`, royalty: 2300},
]

const actressRoyalty = actress.reduce (function (acc, person){
    acc += person.royalty // Мы тут присваиваем к acc person.royalty
    return acc
}, 0)

console.log(actressRoyalty) // 11980

// !Чейнинг - когда мы подряд вызываем несколько методов.

const actressRoyalty = actress
.filter (person => person.royalty > 2500) //Фильтр вызывает новый массив. А метод reduce его меняет.
.reduce ((acc, person) => {
    acc += person.royalty
    return acc
}, 0) 

console.log(actressRoyalty) // 9680

Ассинхронность
==============

// Чтобы выполнить код, нам нужен JavaScript Engine (движок) — программа, которая «читает и выполняет» то, что мы написали. Самый распространённый движок среди всех — это V8, он используется в Google Chrome и Node.js.

// Выполнение JS-кода — однопоточное. Это значит, что в конкретный момент времени движок может выполнять не более одной строки кода. То есть вторая строка не будет выполнена, пока не выполнится первая.

// Такое выполнение кода (строка за строкой) называется синхронным.

Ассинхронные функции
--------------------

setTimeout () // Функция, которая отвечает за вызов функции или выполнение фрагмента кода после указанной задержки.

// Принимает в себя два параметра один из которых обязательный: колбэк функцию и отрезок времени в милисикундах (1 сек = 1000 милисек). 

const timeout = setTimeout(() => {
    console.log('After timeout')
    }, 2500)

clearTimeout (название констаны с функцией) // Отменить дей-е функции setTimeout

setInterval / clearInterval // Одно и то же сообщение будет выводиться с заданным интервалом.

Промисы
-------

// Созданы, чтобы убрать большое нагромождение кода

// Интерфейс Promise (промис) представляет собой обёртку для значения, неизвестного на момент создания промиса. Он позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными: вместо конечного результата асинхронного метода возвращается своего рода обещание (дословный перевод слова "промис") получить результат в некоторый момент в будущем.

// Promise может находиться в трёх состояниях:

// * ожидание (pending): начальное состояние, не исполнен и не отклонён.
// * исполнено (fulfilled): операция завершена успешно.
// * отклонено (rejected): операция завершена с ошибкой.

// При создании промис находится в ожидании (pending), а затем может стать исполненным (fulfilled), вернув полученный результат (значение), или отклонённым (rejected), вернув причину отказа. В любом из этих случаев вызывается обработчик, прикреплённый к промису методом then. (Если в момент назначения обработчика промис уже исполнен или отклонён, обработчик всё равно будет вызван, т.е. асинхронное исполнение промиса и назначение обработчика не будет происходить в «состоянии гонки», как, например, в случае с событиями в DOM.)

// Объект функции с двумя аргументами resolve и reject. Функция executor получает оба аргумента и выполняется сразу, ещё до того как конструктор вернёт созданный объект. Первый аргумент (resolve) вызывает успешное исполнение промиса, второй (reject) отклоняет его. Обычно функция executor описывает выполнение какой-то асинхронной работы, по завершении которой необходимо вызвать функцию resolve или reject. Обратите внимание, что возвращаемое значение функции executor игнорируется.

// executor колбек функция внутри промиса, resolve = всё хорошо, reject = произошла ошибка.

// Метод Promise.resolve(value) возвращает Promise выполненный с переданным значением. value - это любое значение, включая текст

const delay = (wait = 1000) => {
    const promise = new Promise((resolve, reject) => {
      setTimeout(() => {
        // resolve() 
        reject('Что-то пошло не так. Повторите попытку')

        // ВАЖНО: resolve идёт перед reject
      }, wait)
    })
    return promise
  }

delay(2500)
  .then(() => {
       console.log('After 2 seconds')
  })
  .catch(err => console.error('Error:', err)) // работает только в случае отклонения промиса.
  .finally(() => console.log('Finally')) // Метод finally() возвращает Promise. Когда промис был выполнен, вне зависимости успешно или с ошибкой, указанная функция будет выполнена. Это даёт возможность запустить один раз определённый участок кода, который должен выполниться вне зависимости от того, с каким результатом выполнился Promise.

const getData = () => new Promise(resolve => resolve([
    1, 1, 2, 3, 5, 8, 13
  ])) // Можно записать промис и так

async function asyncExample() { // C помощью async можно сделать функцию асинхронной
    try { // опеартор try catch
      await delay(3000)
      const data = await getData() // Оператор await заставляет функцию, объявленную с использованием оператора async, ждать выполнения Promise и продолжать выполнение после возвращения Promise значения. Впоследствии возвращает полученное из Promise значение. 
      console.log('Data', data)
    } catch (e) {
      console.log(e)
    } finally {
      console.log('Finally') // Такой же файнали как и в промисах
    }
  }

Работа с DOM
============

// Во вкладке Elements находится DOM-дерево

// Команда document показывает DOM-дерево в console.log. 

// document и window - глобальные функции.

// Вызывая window и какую-то функцию мы вызываем ее в общем окне.

window.alert () // вызов окна

window.confirm () // вызов окна, с возможностью выбора

document.getElementById () // Найти элемент в DOM дереве

const heading = document.getElementById('hello')

console.dir (heading.textContent)

heading.textContent = `Hello Mir` //Поменять текст внутри id, который мы нашли шагом выше

heading.style.colour = `red` //Надпись станет красной

// Console.dir это способ посмотреть в консоли свойства заданного javascript объекта. Через неё можно искать нужные методы.

const heading = document.getElementById (`hel`)

// Чтобы работало необходимо внести изменения в html-файл: добавить айди и класс <h1 id="hello" class="heading">Hello World!</h1>.

setTimeout(() => {
    addStylesTo(heading) //Выполняем фукцию для константы выше
  }, 1500)

function addStylesTo(node, text, color = 'red', fontSize) { //Здесь цвет параметр по умолчанию, если мы его отдельно не задаём. Но если зададим отдельно в другой ф-ции, то цыет поменяется.
    node.textContent = text // Поменять текст
    node.style.color = color // Поменять цвет текста
    node.style.textAlign = 'center' //Поменять местоположение текста на экране
    node.style.backgroundColor = 'black' //Цвет фона
    node.style.padding = '2rem' // Добавить падинг. Свойство padding устанавливает внутренние отступы/поля со всех сторон элемента. Область отступов это пространство между содержанием элемента и его границей. Отрицательные значения не допускаются.
    node.style.display = 'block'
    node.style.width = '100%'
}

node. // Параметр, который мы передаём в функцию

// falsy значения: '', undefined, null, 0, false

// Мы можем менять текст для уже заданной функции. Как?

setTimeout(() => {
    addStylesTo(heading, `Всё будет хорошо!`) //Этот текст будет вместо того, что мы задали в функции 
  }, 1500)

Как поменять внешний вид текста без id?
---------------------------------------

<h2>This is heading 2</h2>

// Задаем надписи класс: <h2 id="sub-hello" class="h2-class">This is heading 2</h2>

//Теперь выполняем метод применимый к классу:

const heading2 = document.getElementsByClassName('h2-class')[0] // 0 это индекс искомого текста 
//Устаревший метод 

//Современный метод:

const heading2 = document.querySelector('.h2-class') //В скобрках пишем css селектор, наример, #sub-hello - id (пишется с решеткой), класс пишется с точкой вначале ('.h2-class'), по <h2> тоже можно искать.

// .querySelector возвращает всегда один элемент

// .querySelectorAll берет все теги, а не один. Возвращает их в консоли в форма массива.

MouseEvent
----------

// Как заставить текст меняться по клику?

// Интерфейс MouseEvent представляет собой событие, которое происходит в результате взаимодействия пользователя с манипулятором ( например, мышью). Наиболее частые из таких событий: click (en-US), dblclick (en-US), mouseup (en-US), mousedown (en-US).

heading.onclick = () => { //Свойство onclick возвращает обработчик события click на текущем элементе.
    if (heading.style.color === 'red') { //Если мы кликаем по надписи она приобретает аткие параметры
      heading.style.color = '#000'
      heading.style.backgroundColor = '#fff'
    } else {
      heading.style.color = 'red' //В другом случае она остаётся такой же
      heading.style.backgroundColor = '#000'
    }
  }

// Другой способ:


heading2.addEventListener('dblclick', () => { //Добавляем условие (двойной клик) и функцию, что произойдёт прои этиом условии
    if (heading2.style.color === 'yellow') {
      heading2.style.color = '#000'
      heading2.style.backgroundColor = '#fff'
    } else {
      heading2.style.color = 'yellow'
      heading2.style.backgroundColor = '#000'
    }
  })


CSS
===

{
    Свойство: значение; //Всё это правило
    Свойство: значение;
    Свойство: значение;
}

h1 {
    color: blue;
}

// Как подключить стили на страницу?

<h1 style="color: blue">Всем привет! Я Вика</h1> //Неудобно

//Можно подключить через сторонний документ:

<link rel="stylesheet" //Вид, что это таблица стилей
href="style.css"> // Путь до файла

//Лучший вариант:

<style> h1 {

    font-family: Georgia, 'Times New Roman', Times, serif; //Тип шрифта: Основной, запасной, Особенности шрифта (с засечками или без)
    font-size: 64 px; //Размер шрифта 
    font-weight: bold; //Жирность шрифта
    color: blue;
    margin-bottom: 50 px //Отступ снизу
    margin-top: 50 px //Отступ сверху
    background-color: yellow; //Цвет фона
    border: 2px solid red; //Обводка фона и её цвет
    padding-top: 10px; //Внутренний отступ сверху
    padding-bottom: 10px; //Внутренний отступ снизу
    
} 
</style> //Пишется в head

body {

    font-family: 'Muli', sans-serif;
    overflow: hidden;
    margin: 0;
    background: #111;
    height: 100vh; // Здесь задаём всей странице один фон, который будет покрывать всю страницу
    display: flex; // Флекс-контейнер: элемент, к которому применяется свойство display: flex. Вложенные в него элементы подчиняются правилам раскладки флексов. Флекс-элемент: элемент, вложенный во флекс-контейнер. ТО что этоменты на экране можно перемещать.
    // Когда мы задаём какому-то элементу значение flex для свойства display, мы превращаем этот элемент в флекс-контейнер. Внутри него начинает действовать флекс-контекст, его дочерние элементы начинают подчиняться свойствам флексбокса.
    justify-content: center; // Выравнивание элементов по центру. Браузер сам выравнивает
    align-items: center;//CSS свойство align-items выравнивает flex-элементы текущей flex-линии таким же образом, как и justify-content, но в перпендикулярном направлении.
}


.container {
    width: 100%;
    display: flex;
    padding: 0 20px;
  } //  Контейнеры используются для размещения, вставки и (иногда) центрирования содержимого внутри них. 


//Можно задать параметры классу, который мы указали в html: class="slide"

.slide {
    height: 80vh; //Расположение на экране в %
    border-radius: 20px; // border-radius — это CSS-свойство, позволяющее разработчикам определять, как скругляются границы блока. Закруглённость каждого угла определяется с помощью одного или двух радиусов, определяя его форму: круг или эллипс.
    margin: 10px; //Расстояние между элементами. CSS свойство margin определяет внешний отступ на всех четырёх сторонах элемента.
    cursor: pointer; //Если навести курсор на элемент, то будет показано, что с ним можно что-то сделать
    color: #fff;
    flex: 1;
    // Свойство CSS flex - это сокращённое свойство, определяющее способность гибкого элемента растягиваться или сжиматься для заполнения собой доступного свободного пространства. Это свойство устанавливает flex-grow, flex-shrink и flex-basis.

//    Начальное значение как и у каждого из подсвойств этого свойства:
//    flex-grow: 0
//    flex-shrink: 1
//    flex-basis: auto

    background-size: cover; //Размер фона. cover - ключевое значение
    background-position: center; //Начальная позиция для фонового элемента
    background-repeat: no-repeat; //Будет ли повторяться изображение

    box-shadow:4px 4px 9px rgba(198, 198, 198, 0.36); //CSS-свойство box-shadow добавляет тень к элементу. Через запятую можно задать несколько теней. Тень описывается смещениями по оси X и Y относительно элемента, радиусом размытия и распространения, а также цветом.
}

Opacity
// CSS-свойство opacity устанавливает непрозрачность элемента. Непрозрачность - это степень, в которой содержимое скрывается за элементом, является противоположностью прозрачности. 0 - ничего не видно, 1 - видно всё. 

transition
// transition: transform 0.5s ease-in-out Заставляет двигаться свойство transform. Transition позволяет определять переходное состояние между двумя состояниями элемента.


Наследование
------------

//Задавая условия родительскому элементу, напр. body, мы задаем условия и элементам внутри него.

Адаптивная верстка
------------------

img {
    width: 100%; // Картинка подстраивается под размер экрана
    max-whidth: 300px; //Ограничение до какого размера может изменяться на экране картинка
}

// px не подстраивается под размер экрана, em и rem подстраиваются.

* px (пиксели): Количество пикселей в высоту, на которое вы хотите расположить текст. Это абсолютная единица измерения - она приводит к одному и тому же конечному вычисленному значению для шрифта на странице практически в любой ситуации.

* ems: 1 em равен размеру шрифта, установленному на родительском элементе текущего элемента, который мы стилизуем (точнее, ширине заглавной буквы M, содержащейся внутри родительского элемента). Это может оказаться сложным, если у вас много вложенных элементов с разными размерами шрифта, но это возможно, как вы увидите ниже. Почему? Это вполне естественно, когда вы привыкнете к этому, и вы можете использовать em для определения размера всего, а не только текста. Вы можете создать целый веб-сайт, используя em, что упрощает его обслуживание.

* rems: Они работают так же, как и em, за исключением того, что 1 rem равен размеру шрифта, установленному для корневого элемента документа (т.е. <html>), а не для родительского элемента. Это значительно упрощает математические вычисления для определения размера шрифта, хотя если вы хотите поддерживать действительно старые браузеры, вы можете столкнуться с трудностями - rem не поддерживается в Internet Explorer 8 и ниже.

div 
---- 

// Элемент разделения контента HTML (<div>) является универсальным контейнером для потокового контента. Он не влияет на контент или макет до тех пор, пока не будет стилизован с помощью CSS.

Импортировать шрифт
-------------------

@import url("https://fonts.googleapis.com/css?family=Roboto&display=swap");

Как сделать перетаскиваемые объекты
------------------------------------ 

//Свойство target интерфейса Event является ссылкой на объект, который был инициатором события. Он отличается от Event.currentTarget, если обработчик события вызывается во время всплытия (bubbling) или захвата события.

meta
----

Тег, который позволяет добавить описание к заголовку страницы. Описание будет отображаться в гугл при поиске. 

<meta name="description" content="Здесь пишеться непостредственно описание">

//ul - элемент списка с точками
//ol - список с цифрами
//margin - внешний отступ
//paddin - внутренний отступ

Строчные элменты
----------------

* На них не действует свойство Width и вертикальные отступы (margin)

* Внутри строчного элемента не может быть блочного элемента

shift + alt + a - Закоментирвать

* Про отсупы: Если отступ сверхк и снизу пересекаются, то браузер оставляет просто тот отступ, что больше 

Правила верстки
---------------

!!! Padding – это отступ от содержимого до края блока (внутри блока), margin – расстояние от одного блока до другого, межблоковое пространство. 

* Правильно использовать margin-right и margin-bottom, остальные марджины лучше стараться не сипользовать

* Элемент не может двигать сам себя, его может двигать только его сосед.

* Если нет соседнего элемента сверху или слева, мы используем padding top или padding left у родителя.

Псевдоклассы
""""""""""""
Нужны когда нужно изменить свойство элемента при наведении на него:

*Тег*:hover (Наведение) - Ховер тут псевдокласс

* last-child - свойства применяются только к последнему элменту

Добавление фонового изображения
------------------------------

!!! Тег <img> используется для изображений, которые являются чатью контента (логотип, иконки). 

background-image: url(../img/01-Картинка-фона.jpg); - свойство для указания пути до фонового изображения

../ - выход из папки

background-position - расположение изображения в контейнере

background-size - свойство для указания размера фонового изображения

* contain - подстравивается под размер контейнера (по высоте рамки)
* cover - покрывает весь контейнер (растягивалась по ширине)

background-repeat - повторение изображения на всё свободное место контейнера

background-attachment - настройка изображения при прокрутке страницы (редко используется)

Вместо свойств выше можно использовать просто background:

background: url(../img/01-Картинка-фона.jpg) center/cover no; (Сочетание свойств position и size пишется через слеш)

Position
---------

position: static - обычное поведение элемента (базовое значение)

relative - позволяет отталкивать элемент от других элементов или от родительского. 

Отодвигать с помощью top, bottom, screenLeft, right. Противоположные значения не должны использоваться вместе.

absolute - заставляет элемент отталкиваться от body, а не от других элементов, т.е. вырывает элемент из потока.
Не отталкивается от body, если у родительского элемента есть position: relative. 

!!! relative отталкивается от соседей, а absolute нет.

fixed - фиксирует элемент в заданном месте при прокрутке.

sticky - при прокрутке страницы до элемента, которому задан sticky, он закрепляется в заданной позиции.

Например: 

{
position: sticky;
top: 0px;
} - когда доведем до него курсор закрепиться на условии top: 0px;

Z-index
-------

Позволяет распологать элементы друг над другом или под друг другом.

Третье измерение. По умолчанию у всех элементов 0. 

Не работает сам по себе, а только с позиционированными элементами. 

Позволяет распологать элементы друг над другом или под друг другом.

!!! margin: 0 auto; - выровнять по центру. Работает только если у элемента есть width. Выравнивает посередине только по горизонтали. 

* {} - Применить ко всем тегам

Расчёт адаптивного отступа
--------------------------

* Высчитать сколько размер отступа в процентах от общего размера блока

Длина отступа (разделить на) длину блока * 100

Box-sizing 
----------

По умолчанию в блоковой модели CSS ширина и высота, которую вы задаёте элементу применяется только для контента элемента. Если у элемента есть граница или внутренний отступ, то они добавляются к ширине и высоте, чтобы получить отображаемый на экране размер. Это значит, что когда вы выставляете ширину и высоту, вам придётся изменять значение, при добавлении границ и отступов. Например, если у вас есть четыре блока с width: 25%; , и у какого-нибудь из них есть граница или внутренний отступ слева или справа, то по умолчанию они не поместятся на одной строке.

Свойство box-sizing может изменять это поведение:

content-box 

даёт стандартное поведение свойства box-sizing. Если вы выставите элементу ширину 100 пикселей, то ширина его контента будет 100 пикселей, а ширина границ и внутренних отступов при рендере будет добавлена к финальной ширине, делая элемент шире ста пикселей.

border-box 

говорит браузеру учитывать любые границы и внутренние отступы в значениях, которые вы указываете в ширине и высоте элемента. Если вы выставите элементу ширину 100 пикселей, то эти 100 пикселей будут включать в себя границы и внутренние отступы, а контент сожмётся, чтобы выделить для них место. Обычно это упрощает работу с размерами элементов.

**Примечание:**Часто выставление box-sizing: border-box полезно для размещения элементов. Оно сильно упрощает работу с размерами элементов, и как правило устраняет ряд подводных камней, на которые вы можете наткнуться, размещая контент. С другой стороны, используя position-relative или position: absolute, box-sizing: content-box позволяет позиционным значениям быть зависимыми только от контента, а не от границ и отступов, что иногда желательно.

API
----

* Обращение клиента к стороннему сервису

API (Application programming interface) — это контракт, который предоставляет программа. «Ко мне можно обращаться так и так, я обязуюсь делать то и это».

Контракт включает в себя:
саму операцию, которую мы можем выполнить,
данные, которые поступают на вход,
данные, которые оказываются на выходе (контент данных или сообщение об ошибке).

Вызвать API можно как напрямую, так и косвенно:
Система вызывает функции внутри себя
Система вызывает метод другой системы
Человек вызывает метод
Автотесты дергают методы
Пользователь работает с GUI

Когда говорят про API с тестировщиком, обсуждают два варианта:
автотесты на уровне API (умение автоматизировать)
интеграцию между двумя разными системами (обычно SOAP или REST, то есть работу в SOAP Ui или Postman).
