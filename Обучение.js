* Оператор строгого равенства (===) проверяет, равны ли два его операнда, возвращая булевский результат. В отличие от оператора равенства, оператор строгого равенства всегда считает операнды разных типов разными.

Оператор сложения с присваиванием (+=) добавляет значение правого операнда к переменной и присваивает переменной результат. Типы двух операндов определяют поведение оператора сложения с присваиванием. Добавление или конкатенация возможны.

Объе́ктно-ориенти́рованное программи́рование (сокр. ООП) 
// — методология программирования, основанная на представлении программы в виде совокупности взаимодействующих объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования[1].

* Термин «полифил» означает, что скрипт «заполняет» пробелы и добавляет современные функции.

Булевая логика
==============

* Логиеские операторы - обычно используются с булевыми (логическими) значениями; при этом возвращаемое ими значение также является булевым.

&& (и)
------

! Если есть false, то всегда возвращает false => Возвращает операнд expr1, если он может быть преобразован в false; в противном случае возвращает операнд expr2.

var a1 =  true && true;     // t && t возвращает true
var a2 =  true && false;    // t && f возвращает false
var a3 = false && true;     // f && t возвращает false
var a4 = false && (3 == 4); // f && f возвращает false
var a5 = "Cat" && "Dog";    // t && t возвращает Dog
var a6 = false && "Cat";    // f && t возвращает false
var a7 = "Cat" && false;    // t && f возвращает false

|| (или)
--------

! Если есть true, то всегда возвращает true => Возвращает операнд expr1, если он может быть преобразован в true; в противном случае возвращает операнд expr2.

var o1 =  true || true;     // t || t возвращает true
var o2 = false || true;     // f || t возвращает true
var o3 =  true || false;    // t || f возвращает true
var o4 = false || (3 == 4); // f || f возвращает false
var o5 = "Cat" || "Dog";    // t || t возвращает Cat
var o6 = false || "Cat";    // f || t возвращает Cat
var o7 = "Cat" || false;    // t || f возвращает Cat

Логическое НЕ (!expr)
------------

! Обозначает НЕ

var n1 = !true;  // !t возвращает false
var n2 = !false; // !f возвращает true
var n3 = !"Cat"; // !t возвращает false

Функции
========

* Чтобы упростить некоторые куски кода.

function calculateL(penis) {
    return 2021 + penis
}

console.log(calculateL(152)) //Вот тут в скобках, где 152, можно подставить любую хуйню. 

В консоли высветиться 2173. По сути мы можем высчитывать какое выражение, меняя одну переменную. 

Можно писать несколько сторочек подряд:

console.log(calculateL(152))
console.log(calculateL(13))
console.log(calculateL(7895))

Ещё один пример:

function calculateL(penis) {
    return 2021 + penis
}

function calculateSize(penis, manName) {
    const bigPenis = calculateL(penis)

    console.log(`У ` + manName + ` длина хуя ` + bigPenis + ` см.`)
}

calculateSize (150, `Саши`)

Вышло "У Саши длина хуя 2171 см."

!Не надо забывать расставлять пробелы в кавычках текста, он сам их не ставит. 

В примере выше мы подставили функцию из предыдущего, и запустили её в констоль логе вместе с этой. 

Мы можем также вводить в function конструкции с if (про них написано в бумажном блокноте).

Массивы
=======

* Массивы являются спископодобными объектами, чьи прототипы содержат методы для операций обхода и изменения массива. Ни размер JavaScript-массива, ни типы его элементов не являются фиксированными.

const N = [156, 111, 5050, 62158] - Массив указывается в квадратных скобках
console.log(N) - в консоль выводится массив в таком виде:

(4) [156, 111, 5050, 62158]
0: 156
1: 111
2: 5050
3: 62158
length: 4
[[Prototype]]: Array(0)

Как менять элементы в массиве?

N [1] = `сотка`

В консоли выйдет: [156, 'сотка', 5050, 62158]

* (Название массива).length - говорит сколько элементов внутри массива. Это тоже вводить в консоль логе. Пр: console.log(N.length)

Как сложить новый элемент в конец массива?

N [N.length] = 121
console.log(N) => [156, 'сотка', 5050, 62158, 121]

var arr = ['первый элемент', 'второй элемент', 'последний элемент'];
console.log(arr[0]);              // напечатает 'первый элемент'
console.log(arr[1]);              // напечатает 'второй элемент'
console.log(arr[arr.length - 1]); // напечатает 'последний элемент'

Объекты
=======

// Объекты – это ассоциативные массивы с рядом дополнительных возможностей.

// Они хранят свойства (пары ключ-значение), где:

// Ключи свойств должны быть строками или символами (обычно строками).
// Значения могут быть любого типа.
// Чтобы получить доступ к свойству, мы можем использовать:

// Запись через точку: obj.property.
// Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].
// Дополнительные операторы:

// Удаление свойства: delete obj.prop.
// Проверка существования свойства: "key" in obj.
// Перебор свойств объекта: цикл for 
for (let key in obj).
// То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.

// В JavaScript есть много других типов объектов:

// Array для хранения упорядоченных коллекций данных,
// Date для хранения информации о дате и времени,
// Error для хранения информации об ошибке.
// … и так далее.

//!!Числовые свойства (только целые числа) объекта идут по возрастанию, остальные тому как они объявлены внутри объекта. 

// Внутри объекта находятся СВОЙСТВА

// В объект мы группируем определённое количество значений. Если в массиве мы создаём группу, то в объекте абсолютно разные структуры.

// !Правильнее всего создавать объекты через фигурные скобки.

const L = {
    *значения для каких-либо данных*
    *Я сама решаю, какими данными заполнять объект*
}

Пример:

const suka = {
    Name: `Vuka`,
    Status: `Soska`,
    Age: 22,
    greet: function () { // greet - метод, потому что находится внутри const
        console.log (`Вика - соска нереалка`)
    } // - Вот тут мы вывели функцию: отобразить в консоли эту фразу, функция запускается, если есть команда greet.
}

console.log (suka.Name) или console.log (suka [`Name`]) => Vuka // Выводим значение конкретного свойства
suka.greet() => Вика - соска нереалка

// !Не забывать писать текст в кавычках ``.

// !Между значениями ставятся запятые.

//Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:

let user = {
    name: "John",
    age: 30,
    "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
  };

//Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:

//Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. Такой способ сработает с любым именем свойства:

let user = {};

// присваивание значения свойству
user["likes birds"] = true;

// получение значения свойства
alert(user["likes birds"]); // true

// удаление свойства
delete user["likes birds"];

for...in
=========

Цикл for...in проходит через перечисляемые свойства объекта. Он пройдёт по каждому отдельному элементу.

Синтаксис

for (variable in object) {...
}
variable

// Другое (очередное) имя свойства назначается переменной на каждой итерации.

object

// Объект, по чьим свойствам мы проходим

Описание
---------

// Цикл for...in проходит только по перечисляемым свойствам. Объекты, созданные встроенными конструкторами, такими как Array и Object имеют неперечисляемые свойства от Object.prototype и String.prototype, например, от String-это indexOf(), а от Object - метод toString(). Цикл пройдёт по всем перечисляемым свойствам объекта, а также тем, что он унаследует от конструктора прототипа (свойства объекта в цепи прототипа).

Удаление, добавление и модификация свойств
------------------------------------------

// Цикл for...in проходит по свойствам в произвольном порядке (см. оператор delete для того, чтобы узнать почему порядок прохода может отличаться в зависимости от браузера). Если свойство изменяется за одну итерацию, а затем изменяется снова, его значением в цикле является его последнее значение. Свойство, удалённое до того, как до него дошёл цикл, не будет участвовать в нём. Свойства добавленные в объекты в цикле могут быть пропущены. В общем, лучше не добавлять, изменять или удалять свойство из объекта во время итерации, если по нему ещё не прошли. Нет гарантии, что добавленное свойство будет посещено циклом, низменное после проведения изменений, а удалённое после удаления.

Вычисляемые свойства
====================

// Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.

// Пример:

let fruit = prompt("Какой фрукт купить?", "apple");

let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit
};

alert( bag.apple ); // 5, если fruit="apple"

// Смысл вычисляемого свойства прост: запись [fruit] означает, что имя свойства необходимо взять из переменной fruit.

// И если посетитель введёт слово "apple", то в объекте bag теперь будет лежать свойство {apple: 5}.

Проверка существования свойства, оператор «in»
=============================================

// В отличие от многих других языков, особенность JavaScript-объектов в том, что можно получить доступ к любому свойству. Даже если свойства не существует – ошибки не будет!

// При обращении к свойству, которого нет, возвращается undefined. Это позволяет просто проверить существование свойства:

let user = {};

alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
Также существует специальный оператор "in" для проверки существования свойства в объекте.

// Синтаксис оператора:

"key" in object

// Пример:

let user = { name: "John", age: 30 };

alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует

// Обратите внимание, что слева от оператора in должно быть имя свойства. Обычно это строка в кавычках.

Копирование объектов и ссылки
==============================

// Объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не «значение объекта», а «ссылку» (адрес в памяти) на это значение. Таким образом, копирование такой переменной или передача её в качестве аргумента функции копирует эту ссылку, а не сам объект.

// Все операции с использованием скопированных ссылок (например, добавление/удаление свойств) выполняются с одним и тем же объектом.

// Чтобы создать «реальную копию» (клон), мы можем использовать Object.assign для так называемой «поверхностной копии» (вложенные объекты копируются по ссылке) или функцию «глубокого клонирования», такую как _.cloneDeep(obj).

Как клонировать объект?
----------------------

Также мы можем использовать для этого метод Object.assign.

// Синтаксис:

// Object.assign(dest, [src1, src2, src3...])
// Первый аргумент dest — целевой объект.
// Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
// Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
// Возвращает объект dest.

Флаги и дескрипторы свойств
===========================

Помимо значения value, свойства объекта имеют три специальных атрибута (так называемые «флаги»).

writable – если true, свойство можно изменить, иначе оно только для чтения.
enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.
// Мы ещё не встречали эти атрибуты, потому что обычно они скрыты. Когда мы создаём свойство «обычным способом», все они имеют значение true. Но мы можем изменить их в любое время.

// Сначала посмотрим, как получить их текущие значения.

Метод Object.getOwnPropertyDescriptor позволяет получить полную информацию о свойстве.

// Его синтаксис:

// let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
// obj
// Объект, из которого мы получаем информацию.
// propertyName
// Имя свойства.
Возвращаемое значение – это объект, так называемый «дескриптор свойства»: он содержит значение свойства и все его флаги.

Чтобы изменить флаги, мы можем использовать метод Object.defineProperty.

Его синтаксис:

Object.defineProperty(obj, propertyName, descriptor)
// obj, propertyName
// Объект и его свойство, для которого нужно применить дескриптор.
// descriptor
// Применяемый дескриптор.
// Если свойство существует, defineProperty обновит его флаги. В противном случае метод создаёт новое свойство с указанным значением и флагами; если какой-либо флаг не указан явно, ему присваивается значение false.

// Например, здесь создаётся свойство name, все флаги которого имеют значение false:

let user = {};

Object.defineProperty(user, "name", {
  value: "John"
});

let descriptor = Object.getOwnPropertyDescriptor(user, 'name');

alert( JSON.stringify(descriptor, null, 2 ) );
/*
{
  "value": "John",
  "writable": false,
  "enumerable": false,
  "configurable": false
}
 */
// Сравните это с предыдущим примером, в котором мы создали свойство user.name «обычным способом»: в этот раз все флаги имеют значение false. Если это не то, что нам нужно, надо присвоить им значения true в параметре descriptor.

// Теперь давайте рассмотрим на примерах, что нам даёт использование флагов.

Свойства - геттеры и сеттеры
============================

// Есть два типа свойств объекта.

// Первый тип это свойства-данные (data properties). Мы уже знаем, как работать с ними. Все свойства, которые мы использовали до текущего момента, были свойствами-данными.

// Второй тип свойств мы ещё не рассматривали. Это свойства-аксессоры (accessor properties). По своей сути это функции, которые используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта.


Геттеры и сеттеры
------------------

Свойства-аксессоры представлены методами: «геттер» – для чтения и «сеттер» – для записи. При литеральном объявлении объекта они обозначаются get и set:

let obj = {
    get propName() {
      // геттер, срабатывает при чтении obj.propName
    },
  
    set propName(value) {
      // сеттер, срабатывает при записи obj.propName = value
    }
  };

// Геттер срабатывает, когда obj.propName читается, сеттер – когда значение присваивается.

// Дескрипторы свойств-аксессоров отличаются от «обычных» свойств-данных.

// Свойства-аксессоры не имеют value и writable, но взамен предлагают функции get и set.

// То есть, дескриптор аксессора может иметь:

// get – функция без аргументов, которая сработает при чтении свойства,
// set – функция, принимающая один аргумент, вызываемая при присвоении свойства,
// enumerable – то же самое, что и для свойств-данных,
// configurable – то же самое, что и для свойств-данных.

Методы и this
=====

Функции, которые находятся в свойствах объекта, называются «методами».

// Методы позволяют объектам «действовать»: object.doSomething().

// Методы могут ссылаться на объект через this.

// Значение this определяется во время исполнения кода.

При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.

// Функция может быть скопирована между объектами (из одного объекта в другой).

// Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является object.

// Также ещё раз заметим, что стрелочные функции являются особенными – у них нет this. Когда внутри стрелочной функции обращаются к this, то его значение берётся извне.

Конструктор, оператор "new"
===========================

// Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам нужно создать множество похожих, однотипных объектов, таких как пользователи, элементы меню и так далее.

// Это можно сделать при помощи функции-конструктора и оператора "new".

function User(name) {
    this.name = name;
    this.isAdmin = false;
  }
  
  let user = new User("Jack");
  
  alert(user.name); // Jack
  alert(user.isAdmin); // false

// * Функции-конструкторы или просто конструкторы, являются обычными функциями, но существует общепринятое соглашение именовать их с заглавной буквы.
// * Функции-конструкторы следует вызывать только с помощью new. Такой вызов подразумевает создание пустого this в начале и возврат заполненного в конце.
// * Мы можем использовать конструкторы для создания множества похожих объектов.

Возврат значения из конструктора, return
-----------------------------------------

// Обычно конструкторы не имеют оператора return. Их задача – записать все необходимое в this, и это автоматически становится результатом.

// Но если return всё же есть, то применяется простое правило:

// При вызове return с объектом, вместо this вернётся объект.
// При вызове return с примитивным значением, оно проигнорируется.
// Другими словами, return с объектом возвращает этот объект, во всех остальных случаях возвращается this.

Опциональная цепочка '?.'
======================

Синтаксис опциональной цепочки ?. имеет три формы:

// obj?.prop – возвращает obj.prop если obj существует, в противном случае undefined.
// obj?.[prop] – возвращает obj[prop] если obj существует, в противном случае undefined.
// obj.method?.() – вызывает obj.method(), если obj.method существует, в противном случае возвращает undefined.

Как мы видим, все они просты и понятны в использовании. ?. проверяет левую часть на null/undefined и позволяет продолжить вычисление, если это не так.

Цепочка ?. позволяет безопасно получать доступ к вложенным свойствам.

// Тем не менее, мы должны использовать ?. осторожно, только там, где по логике кода допустимо, что левая часть не существует. Чтобы он не скрывал от нас ошибки программирования, если они возникнут.

Тип данных Symbol
=================

// Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.

// Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа.

// Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы были равны, то следует использовать глобальный реестр: вызов Symbol.for(key) возвращает (или создаёт) глобальный символ с key в качестве имени. Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.

// Символы имеют два основных варианта использования:

// «Скрытые» свойства объектов.

// Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в for..in, так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.

// Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.

// Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее.

// Технически символы скрыты не на 100%. Существует встроенный метод Object.getOwnPropertySymbols(obj) – с его помощью можно получить все свойства объекта с ключами-символами. Также существует метод Reflect.ownKeys(obj), который возвращает все ключи объекта, включая символьные. Так что они не совсем спрятаны. Но большинство библиотек, встроенных методов и синтаксических конструкций не используют эти методы.

Преобразование объектов в примитивы
===================================

// Преобразование объекта в примитив вызывается автоматически многими встроенными функциями и операторами, которые ожидают примитив в качестве значения.

// Существует всего 3 типа (хинта) для этого:

// "string" (для alert и других операций, которым нужна строка)
// "number" (для математических операций)
// "default" (для некоторых других операторов, обычно объекты реализуют его как "number")
// Спецификация явно описывает для каждого оператора, какой ему следует использовать хинт.

// Алгоритм преобразования таков:

// Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует,
// В случае, если хинт равен "string"
// происходит попытка вызвать obj.toString() и obj.valueOf(), смотря что есть.
// В случае, если хинт равен "number" или "default"
// происходит попытка вызвать obj.valueOf() и obj.toString(), смотря что есть.
// Все эти методы должны возвращать примитив (если определены).

// На практике часто бывает достаточно реализовать только obj.toString() в качестве универсального метода для преобразований к строке, который должен возвращать удобочитаемое представление объекта для целей логирования или отладки.


Объекты. Продвинуто
===================

// Объекты не итерируемые
// Во внутрь объектов мы можем помещать булевые значения, массивы и функции.

const suka = {
    Name: `Vuka`,
    Status: `Soska`,
    Age: 22,
    Hobby: [`стихи`, `граффити`, `фильмы`],
    IsSexy: true,
    [`key_` + (1 + 3)]: `заебись`// Мы можем записывать названия значений в разных форматах, например в формате строки. Выйдет key_4:"заебись"
    greet () { // Можно не писать function, а просто оставить скобочки
        console.log (`Вика - соска нереалка`)
    } 
}

// Мы можем менять значения внутри объекта

suka.Age++ // В общем описании будет Age: 23

suka.Hobby.push (`баскетбол`) // Добавить единицу в массив. Получится: Hobby: (4) ['стихи', 'граффити', 'фильмы', 'баскетбол']. 

delete suka[`key_4`] // Удалить значение из объекта

Деструктуризация
----------------

// Мы выводим значения внутри объекта в отельные переменные

const {Hobby, Status} = suka // Для каждой еденицы создаётся своя переменная

const {Hobby: Weekend = 10, Status} = suka // Через двоеточие мы можем поменять название переменной, а также ввести значение по умолчанию через знак равно. Последнее при условии, если у единицы внутри объекта значение underfind.

// По-другому это можно записать так:

const Hobby = suka.Hobby
const Status = suka.Status

console.log (Hobby, Status)

Цикл for in и метод Object.keys
-------------------------------

// Цикл for...in проходит через перечисляемые свойства объекта. Он пройдёт по каждому отдельному элементу.

// Опасен, потому что он пробегается не только по ключам объекта, но и заглядывает в его прототип. Чтобы этого избежать нужно написать "проверку".

//for (variable in object) {...
//}
//variable - Другое (очередное) имя свойства назначается переменной на каждой итерации.
// object - Объект, по чьим свойствам мы проходим

for (let key1 in suka) {
    console.log('key:', key1) // В консоль будут выведены свойства объекта в виде строк
}

for (let key1 in suka) { // Вместо key1 может быть любое название
      console.log('key:', key1) // Выводим названия в виде строк 
      console.log('value:', suka[key1]) // Выводим значения свойств
    }


for (let key1 in suka) { // Вместо key1 может быть любое название
    if (suka.hasOwnProperty(key1)) { // Проверка. Метод hasOwnProperty() возвращает логическое значение, указывающее, содержит ли объект указанное свойство. 
    // Т.е. объект suka содержит своё собственное свойство, к-е не содержится в прототипе. Имя этого свойства key1.
      console.log('key:', key1)
      console.log('value:', suka[key1])
    }
}

// Альтернативный способ написать выражение выше объекта

const N = Object.keys (suka) // Метод Object.keys возвращает массив строковых элементов, соответствующих именам перечисляемых свойств, найденных непосредственно в самом объекте. Порядок свойств такой же, как и при ручном перечислении свойств в объекте через цикл.
    
N.forEach((Lol) => { // Тут используем callback функцию
    // Метод forEach() выполняет указанную функцию один раз для каждого элемента в массиве.
    console.log('key:', Lol)  
    console.log('value:', suka[Lol])
}); 

// Можно обойтись без переменной Object.keys(suka).forEach((Lol) => ...

// Результат:

//    key: Name
//    value: Vuka
//    key: Status
//    value: Soska
//    key: Age
//    value: 22
//    key: Hobby
//    value: undefined
//    key: IsSexy
//    value: true
//    key: key_4
//    value: заебись
//    key: greet
//    value: ƒ greet () { 
//       console.log (`Вика - соска нереалка`)
//    }

Сборка мусора
=============

// Основной концепцией управления памятью в JavaScript является принцип достижимости.

// Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти.

// Существует базовое множество достижимых значений, которые не могут быть удалены.

// Например:

// Выполняемая в данный момент функция, её локальные переменные и параметры.
// Другие функции в текущей цепочке вложенных вызовов, их локальные переменные и параметры.
// Глобальные переменные.
// (некоторые другие внутренние значения)
// Эти значения мы будем называть корнями.

// Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.

// Например, если в глобальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то этот объект считается достижимым. И те, на которые он ссылается, тоже достижимы. Далее вы познакомитесь с подробными примерами на эту тему.

Внутренние алгоритмы
-------------------

// Основной алгоритм сборки мусора называется «алгоритм пометок» (от англ. «mark-and-sweep»).

// Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:

// Сборщик мусора «помечает» (запоминает) все корневые объекты.
// Затем он идёт по ним и «помечает» все ссылки из них.
// Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
// …И так далее, пока не будут посещены все достижимые (из корней) ссылки.
// Все непомеченные объекты удаляются.

Движки JavaScript применяют множество оптимизаций, чтобы она работала быстрее и не задерживала выполнение кода.

Вот некоторые из оптимизаций:

Сборка по поколениям (Generational collection)
//  – объекты делятся на два набора: «новые» и «старые». В типичном коде многие объекты имеют короткую жизнь: они появляются, выполняют свою работу и быстро умирают, так что имеет смысл отслеживать новые объекты и, если это так, быстро очищать от них память. Те, которые выживают достаточно долго, становятся «старыми» и проверяются реже.
Инкрементальная сборка (Incremental collection) 
// – если объектов много, и мы пытаемся обойти и пометить весь набор объектов сразу, это может занять некоторое время и привести к видимым задержкам в выполнении скрипта. Так что движок делит всё множество объектов на части, и далее очищает их одну за другой. Получается несколько небольших сборок мусора вместо одной всеобщей. Это требует дополнительного учёта для отслеживания изменений между частями, но зато получается много крошечных задержек вместо одной большой.
Сборка в свободное время (Idle-time collection) 
// – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.

Функции
=======

* Функция может принимать в себя несколько параметров

* Функции в JS являются объектами. Подробно это можно увидеть с помощью команды console.dir ().

Function Declaration
--------------------

function Vuka(Name) {
    console.log (`Мой любимый мем`, Name)
}

Vuka(`Лягушка`)

* Мы можем вызывать функцию когда угодно, т.е. например, сначала написать Вука, а затем уже описать фунцию. То есть создать функцию после. С Function Expression так желать нельзя.

Function Expression
--------------------

* Когда мы складываем функцию в переменную, это называется Function Expression.

const Love = function Vuka(Name) {
    console.log (`Мой любимый мем`, Name)
}

Love (`Лягушка`)

* Функция может быть как безымянная, так и с имененем  

Рекурсия
========

Рекурсия – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач.

// Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.

Итеративный способ: цикл for:

function pow(x, n) {
  let result = 1;

  // умножаем result на x n раз в цикле
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert( pow(2, 3) ); // 8

Рекурсивный способ: упрощение задачи и вызов функцией самой себя:

function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
Обратите внимание, что рекурсивный вариант отличается принципиально.

Когда функция pow(x, n) вызывается, исполнение делится на две ветви:

              if n==1  = x
             /
pow(x, n) =
             \
              else     = x * pow(x, n - 1)
Если n == 1, тогда всё просто. Эта ветвь называется базой рекурсии, потому что сразу же приводит к очевидному результату: pow(x, 1) равно x.
// Мы можем представить pow(x, n) в виде: x * pow(x, n - 1). Что в математике записывается как: xn = x * xn-1. Эта ветвь – шаг рекурсии: мы сводим задачу к более простому действию (умножение на x) и более простой аналогичной задаче (pow с меньшим n). Последующие шаги упрощают задачу всё больше и больше, пока n не достигает 1.

Контекст выполнения, стек
========================
// Теперь мы посмотрим, как работают рекурсивные вызовы. Для этого заглянем «под капот» функций.

// Информация о процессе выполнения запущенной функции хранится в её контексте выполнения (execution context).

Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение this (мы не используем его в данном примере) и прочую служебную информацию.

// Один вызов функции имеет ровно один контекст выполнения, связанный с ним.

// Когда функция производит вложенный вызов, происходит следующее:

// Выполнение текущей функции приостанавливается.
// Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.
// Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
// После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.
// Разберёмся с контекстами более подробно на примере вызова функции pow(2, 3).

Рекурсивные структуры
=====================

// Рекурсивно определяемая структура данных – это структура данных, которая может быть определена с использованием самой себя.

// Например, связанный список может быть определён как структура данных, состоящая из объекта, содержащего ссылку на список (или null).

// list = { value, next -> list }
// Деревья, такие как дерево HTML-элементов или дерево отделов из этой главы, также являются рекурсивными: у них есть ветви, и каждая ветвь может содержать другие ветви.

// Как мы видели в примере sumSalary, рекурсивные функции могут быть использованы для прохода по ним.

Остаточные параметры
=====================

// Когда мы видим "..." в коде, это могут быть как остаточные параметры, так и оператор расширения.

// Как отличить их друг от друга:

Если ... располагается в конце списка параметров функции, то это «остаточные параметры». Он собирает остальные неуказанные аргументы и делает из них массив.
 
Остаточные параметры могут быть обозначены через три точки .... Буквально это значит: «собери оставшиеся параметры и положи их в массив».

Их употребляют в конце перечисления параметров!
// Например, соберём все аргументы в массив args:

// function sumAll(...args) { // args — имя массива
//   let sum = 0;

//   for (let arg of args) sum += arg;

//   return sum;
// }

// alert( sumAll(1) ); // 1
// alert( sumAll(1, 2) ); // 3
// alert( sumAll(1, 2, 3) ); // 6

Если ... встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива.

Полезно запомнить:

// Остаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов.
// С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.
// Вместе эти конструкции помогают легко преобразовывать наборы значений в массивы и обратно.

// К аргументам функции можно обращаться и по-старому — через псевдомассив arguments.

Анонимные функции
=================

let time = 10

setInterval ( function () {
    console.log(++time)
}, 1000) // 1000 - количество мили

=> В консоль выводится значение 10 увеличенное на 1 (11, 12, 13) каждую тясячу милисекунд (секунду)

* clearInterval() отменяет повторяющееся по времени действие, которое было ранее установлено вызовом setInterval(). Если предоставленный параметр
не идентифицирует ранее установленное действие, этот метод ничего не делает.

let time = 10

const TimeAfterTime = setInterval ( function () {
    if (time === 15) {
        clearInterval(TimeAfterTime)
    } else {
        console.log(++time)
    }
}, 1000) 

=>  В консоли будет 11, 12, 13, 14, 15. Функция выше говорит, что переменная будет прибавлять по одному каждую секунду, пока не достигнет 15. 

setTimeout / clearTimeout // Вызов функции или выполнение фрагмента кода после указанной задержки и отмена её.

Стрелочные функции
==================

Стрелочные функции:

Не имеют this.
Не имеют arguments.
Не могут быть вызваны с new.
(У них также нет super, но мы про это не говорили. Про это будет в главе Наследование классов).
Всё это потому, что они предназначены для небольшого кода, который не имеет своего «контекста», выполняясь в текущем. И они отлично справляются с этой задачей!

! Стрелочные, потому что там присутствует такая стрелочка =>.

const Love = function Vuka(Name) {
    console.log (`Мой любимый мем`, Name)
}

Love (`Лягушка`) // Мой любимый мем Лягушка

const arrow = (Name) => {
    console.log (`Мой любимый мем`, Name)
}

arrow(`Пизда`) // Мой любимый мем Пизда

* Оба выражения выше абсолютно идентичны, т.е. можно слово function заменить тупо на стрелочку.

Как ещё можно сократить?

const arrow2 = Name =>  console.log (`Мой любимый мем`, Name)

arrow(`Пизда`) // Мой любимый мем Пизда. Без скобок пишем, потому что переменная всего одна.

const Size = Num => {
    return Num ** 2
}

или

const Size = Num => return Num ** 2

console.log(Size (2)) // В консоли выйдет 4. Суть ф-ции: возводить конкретное число во вторую степень.

Параметры по умолчанию
======================

const LoL = (a, b) => a + b 

console.log(LoL (4, 15)) // 19

console.log(LoL (4)) // NaN

const LoL1 = (a, b = 15) => a + b 

console.log(LoL1 (4))

Можно и так:

const LoL3 = (a = 150, b = a * 2) => a + b

console.log(LoL3 ()) // 450

function Love(...all) {
    let U = 0
    for (let num of all) {
        U += num
    }
    return U
}

const U2 = Love (1, 52, 10, 12)

console.log(U2) // Есть переменная Ю равная нулю. Команда поссчитать сумму всех. Сумма всех прибавить переменную Ю. Вернуть переменную Ю. Через константу Ю2 выводятся числа, которые будут складываться в функции. 

Замыкания
=========

Замыкание - это способность функции в JS запоминать лексическое окружение, в котором она была создана.

– это функция, которая запоминает свои внешние переменные и может получить к ним доступ.

В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в Синтаксис "new Function").

* Используются для создания приватных переменных

function Love (sex) {
    return function (LGBT) {
        console.log (sex + LGBT)
    }
}

const life = Love (`Навсегда`)
console.log (life(`любить`)) => Навсегдалюбить

То есть благодаря константе переменная "секс" становится по умолчанию "Навсегда", а другую переменную мы можем менять.

Лексическое Окружение
=======================

В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.

// Объект лексического окружения состоит из двух частей:

// Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).

// Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

// "Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

// Итого:

// Переменная – это свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом.
// Работа с переменными – это на самом деле работа со свойствами этого объекта.

Контекст
--------

const suka = {
    Name: `Vuka`,
    Status: `Soska`,
    Age: 22,
    Hobby: [`стихи`, `граффити`, `фильмы`],
    IsSexy: true,
    info () { // Выводит сообщения, содержащие некоторую информацию, в Веб-консоль. 
        console.info (`Меня зовут`, this.Name) // this можно использовать вместо suka = универсальное название объекта. 
    }
}

// Метод bind привязывает новый контекст, который мы сами выберем. Метод bind возвращает новую функцию.

const logger = {
    keys () {  //Мы можем использовать метод keys, чтобы выводить в консоль вообще любой объект.
        // У метода может быть любое название. Мы сами придумываем метод.
        console.log (Object.keys (this))
    }
}

const F = logger.keys.bind (suka) // Метод bind возвращает новую функцию, поэтому мы вводим константу.
F () // F, чтобы вывести в console.log

// В console.log будет ['Name', 'Status', 'Age', 'Hobby', 'IsSexy', 'info']

// Мы пользуемся методом keys объекта logger, к-й знает про this, но ничего не знает про suka. Мы говорим, что в данном случае this, будет тем объектом, который мы задали.

// Альтернатива:

// Метод call такой же как и bind, но он просто вызывает значения и не создаёт функцию.

logger.keys.call (suka) // В console.log будет ['Name', 'Status', 'Age', 'Hobby', 'IsSexy', 'info']

const logger = {
    keysPlusValues () {  
        console.log('key:', this)  
        console.log('value:', this[])
    }
}

logger.keysPlusValues.call (suka)

// Как вывести ещё и значения свойств

const logger = {
    keysPlusValues ($) {  
        Object.keys (this).forEach(key => { // key может называться любым именем
            console.log (`"${key}": ${this[key]}`)    
        }
        )
    }
}

logger.keysPlusValues.call(suka)

// "Name": Vuka
// "Status": Soska
// "Age": 22
// "Hobby": стихи,граффити,фильмы
// "IsSexy": true
// "info": info () {  
//        console.info (`Меня зовут`, this.Name)
//    }

// Нельзя использовать function в примере выше, т.к. он создаёт другой контекст, вместо function создаём =>. Стрелочные функции не создают свой собственный контекст. 

//Условия внутри объектов

const logger = {
 
    Conditions (top, betwwen, end) {
        if (top) {
            console.log ('------- Start -------')
        }
        Object.keys (this).forEach((key, index, array) => { // key может называться любым именем
            console.log (`"${key}": ${this[key]}`)  
            if (betwwen && index !== array.length - 1) { // Тут мы задаем как не выводить условие в конце. мы пишем, что индескс не равен -1.
                console.log ('--------------')
            }
        }
        )
        if (end) {
            console.log('------- End -------')
          }
    }
}

logger.Conditions.call (suka)

Устаревшее ключевое слово "var"
=============================

Для «var» не существует блочной области видимости.

Область видимости переменных var ограничивается либо функцией, либо, если переменная глобальная, то скриптом. Такие переменные доступны за пределами блока.

Например:

if (true) {
  var test = true; // используем var вместо let
}

alert(test); // true, переменная существует вне блока if
Так как var игнорирует блоки, мы получили глобальную переменную test.

А если бы мы использовали let test вместо var test, тогда переменная была бы видна только внутри if:

if (true) {
  let test = true; // используем let
}

alert(test); // Error: test is not defined

Существует 2 основных отличия var от let/const:

* Переменные var не имеют блочной области видимости, они ограничены, как минимум, телом функции.

* Объявления (инициализация) переменных var производится в начале исполнения функции (или скрипта для глобальных переменных).

Глобальный объект
=================

// Глобальный объект хранит переменные, которые должны быть доступны в любом месте программы.

// Это включает в себя как встроенные объекты, например, Array, так и характерные для окружения свойства, например, window.innerHeight – высота окна браузера.

// Глобальный объект имеет универсальное имя – globalThis.

// …Но чаще на него ссылаются по-старому, используя имя, характерное для данного окружения, такое как window (браузер) и global (Node.js).

// Следует хранить значения в глобальном объекте, только если они действительно глобальны для нашего проекта. И стараться свести их количество к минимуму.

// В браузерах, если только мы не используем модули, глобальные функции и переменные, объявленные с помощью var, становятся свойствами глобального объекта.

// Для того, чтобы код был проще и в будущем его легче было поддерживать, следует обращаться к свойствам глобального объекта напрямую, как window.x.

Объект функции, NFE
===================

// Функции – это объекты.

// Их свойства:

// name – имя функции. Обычно берётся из объявления функции, но если там нет – JavaScript пытается понять его из контекста.
// length – количество аргументов в объявлении функции. Троеточие («остаточные параметры») не считается.
// Если функция объявлена как Function Expression (вне основного потока кода) и имеет имя, тогда это называется Named Function Expression (Именованным Функциональным Выражением). Это имя может быть использовано для ссылки на себя же, для рекурсивных вызовов и т.п.

// Также функции могут содержать дополнительные свойства. Многие известные JavaScript-библиотеки искусно используют эту возможность.

// Они создают «основную» функцию и добавляют множество «вспомогательных» функций внутрь первой. Например, библиотека jQuery создаёт функцию с именем $. Библиотека lodash создаёт функцию _, а потом добавляет в неё _.clone, _.keyBy и другие свойства (чтобы узнать о ней побольше см. документацию). Они делают это, чтобы уменьшить засорение глобального пространства имён посредством того, что одна библиотека предоставляет только одну глобальную переменную, уменьшая вероятность конфликта имён.

// Таким образом, функция может не только делать что-то сама по себе, но также и предоставлять полезную функциональность через свои свойства.

Синтаксис "new Function"
========================

// Синтаксис:

// let func = new Function ([arg1, arg2, ...argN], functionBody);
// По историческим причинам аргументы также могут быть объявлены через запятую в одной строке.

// Эти 3 объявления ниже эквивалентны:

// new Function('a', 'b', 'return a + b'); // стандартный синтаксис
// new Function('a,b', 'return a + b'); // через запятую в одной строке
// new Function('a , b', 'return a + b'); // через запятую с пробелами в одной строке
// Функции, объявленные через new Function, имеют [[Environment]], ссылающийся на глобальное лексическое окружение, а не на родительское. Поэтому они не могут использовать внешние локальные переменные. Но это очень хорошо, потому что страхует нас от ошибок. Переданные явно параметры – гораздо лучшее архитектурное решение, которое не вызывает проблем у минификаторов.

Планирование: setTimeout и setInterval
======================================

Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».

Для этого существуют два метода:

* setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
* setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

// Методы setInterval(func, delay, ...args) и setTimeout(func, delay, ...args) позволяют выполнять func регулярно или только один раз после задержки delay, заданной в мс.
// Для отмены выполнения необходимо вызвать clearInterval/clearTimeout со значением, которое возвращают методы setInterval/setTimeout.
// Вложенный вызов setTimeout является более гибкой альтернативой setInterval. Также он позволяет более точно задать интервал между выполнениями.
// Планирование с нулевой задержкой setTimeout(func,0) или, что то же самое, setTimeout(func) используется для вызовов, которые должны быть исполнены как можно скорее, после завершения исполнения текущего кода.
// Браузер ограничивает 4-мя мс минимальную задержку между пятью и более вложенными вызовами setTimeout, а также для setInterval, начиная с 5-го вызова.
// Обратим внимание, что все методы планирования не гарантируют точную задержку.

// Например, таймер в браузере может замедляться по многим причинам:

// Перегружен процессор.
// Вкладка браузера в фоновом режиме.
// Работа ноутбука от аккумулятора.
// Всё это может увеличивать минимальный интервал срабатывания таймера (и минимальную задержку) до 300 или даже 1000 мс в зависимости от браузера и настроек производительности ОС.

Числа
=====

num = тупо число                         //Численный тип integer

float = число с десятыми, сотыми и т.д.  //Численный тип float

pow = возведённое в степень число. Пр: 10е3 => 10000 (т.е. 10 в 3 степени)

Константы
---------

В интструментах разработчика в консоли в гугле мы можем вводить Number. и выбирать различные значения.

Например, Number.MAX_SAFE_INTEGER 
9007199254740991

Number.MAX_SAFE_INTEGER - максимальное безопасное целочисленное значение в JavaScript.

MAХ_VALUE 1.7976931348623157e+30 - максимально возможное нецелое число, к-м JS может оперировать 

MIN_VALUE 5e-324 - минимально возможное нецелое число, к-м JS может оперировать 

POSITIVE_INFINITY Infinity - константанта, которая обозначает бесконечность.

NEGATIVE_INFINITY -Infinity - позитивная и негативная бесконечности как в мат анализе

* Как получить значение бесконечности?

1/0 или 2/0 => Indefinity 

Numer.NaN
---------

NaN - Not a number

console.log (typeof NaN) => Numer

!НаН появляется тогда, когда мы делим то, что нельзя делить. Например, число делим на свойство и т.д..

Пр: 

const weird = 2 / underfind
console.log (weird) => NaN

Функция isNaN — проверить, является ли конструкция NaNом.

console.log (isNaN (weird)) => true 

IsFinite
--------

* Передаёт конечно ли число.

console.log (Number.IsFinite (42)) => true // 42 конечно? Да
console.log (Number.IsFinite (Indefinity)) => false // Бесконечность конечна? Нет

parseInt и parseFloat
---------------------

* Преобразует строчку в число 

Пр:

const N = `40`

console.log (N + 2) => 402 (строчка)
console.log (Number.parseInt (N) + 2) => 42 (число)
console.log (parseInt (N) + 2) => 42 (число)

Number.parseInt (N) всё равно, что +N => плюс может также переводить строчку в число

! parseInt не работает с десятичными составляющими числа, т.е. `40,42` он преобразует в 40

! parseFloat - преобразует числа с десятичными. Действует также как и parseInt

Особенности JS
--------------

console.log (0.4 + 0.2) => 0.6000000000000001

console.log ((0.4 + 0.2).toFixed (1)) => 0.6 // Свойство toFixed тупо обрезает знаки после запятой, но число превращается в строчку

=> Как превратить строчку в число? Используем parseFloat 

* parseFloat потому что числа десятичные, были бы целые был бы parseInt.

console.log (parseFloat ((0.4 + 0.2).toFixed (1))) => 0.6 (число) // Не надо забывать брать в скобочки

console.log (+((0.4 + 0.2).toFixed(2))) => 0.6

BigInt
======

* отдельный тип данных, который позволяет оперировать числами больше, чем MAX_SAFE_INTEGER 

MAX_SAFE_INTEGER = 9007199254740991

Пример:

console.log (typeof 9007199254740991000000) => number

console.log (typeof 9007199254740991000000n) => bigint

! bigint входит в операции только друг с другом. Пример: 

console.log (9007199254740991000000n - 900719925474099100n) => 9006298534815516900900n

console.log (10n - 4) // Ошибка, т.к. это разные типы данных

console.log (parseInt (10n) - 4)  => 6 // parseInt преобразует 10n в простое число

console.log (10n - BigInt (4)) => 6n //  BigInt преобразует четвёрку в нужный тип данных

! Мы не можем оперировать с десятичными, так как int это INTEGER.

console.log (5n / 2n) => 2n // Целое число, т.к. инт не работает с десятичными

Math
====

* Работает с математическими значениями.

console.log (Math.E) => 2.718281828459045

console.log (Math.PI) => 3.141592653589793

Math.sqrt // Корень из ...

console.log (Math.sqrt (100)) => 10

Math.pow // Возвести в степень

console.log (Math.pow (5, 5)) => 3125

Math.abs // возвращает абсолютное значение числа

Math.abs('-1');     // 1
Math.abs(-2);       // 2
Math.abs(null);     // 0
Math.abs('');       // 0
Math.abs([]);       // 0
Math.abs([2]);      // 2
Math.abs([1,2]);    // NaN
Math.abs({});       // NaN
Math.abs('string'); // NaN
Math.abs();         // NaN

Math.max // Выводит максимальное значение из списка чисел 
Math.min // Выводит минимальное значение из списка чисел 

console.log (Math.max (101, 156, 8, 856)) => 856

console.log (Math.min (101, 156, 8, 856)) => 8

console.log (Math.floor(10.6)) => 10 // Округляет в меньшую сторону

console.log (Math.ceil(10.2)) => 11 // Округляет в большую сторону

console.log (Math.round(10.2)) => 10 // Возвращает к ближайшему целому 

console.log (Math.trunc(10.2)) => 10 // возвращает целую часть числа путём удаления всех дробных знаков

console.log (Math.random ()) => // Выдаёт рандомное число

Пример того как можно сократить диапазон random: 

function Nuka(max, min) {
    return Math.round (Math.random() * (max - min) + 1)
}

console.log (Nuka(110, 10))

Строки
======

const Name = `Eва`
const films = 15

const porn = `Моя любимая порноактриса ` + Name + ` снялась в ` + films + ` фильмах.`

const porn1 = `Моя любимая порноактриса ${Name} снялась в ${films} фильмах.`

Фразы выше идентичны и выходят в консоли одинаково. Чтобы не ставить стомильонов плюсов используют ${}. 
В скобки можно записать функции (function), переменные, неравенства и т.д.

Методы
-------

const Frase = `Округляет в меньшую сторону.`

console.log (Frase.length) => 27 // Показывает коичество знаков с пробелами

console.log (Frase.toUpperCase()) => ОКРУГЛЯЕТ В МЕНЬШУЮ СТОРОНУ // Пишет текст капсом

console.log (Frase.toLowerCase()) => округляет в меньшую сторону // Пишет только маленькими буквами

console.log (Frase.charAt(7)) => е // Возвращает 7 знак во фразе. Ноль перове число и тоже считается.

console.log (Frase.indexOf(мен)) => 12 // Присутсвует ли там этот элемент. Если да, то выводит с какого индекса он начинается (с какой буквы). Если нет, то выводит -1.

console.log (Frase.startsWith(`Окр`)) => true // Начинается ли с этого выражения фраза

сonsole.log (Frase.endsWith(`ону.`)) => true //По аналогии, только про конец 

сonsole.log (Frase.repeat (4)) // Повторяет фразу несколько раз

'название переменной'.trim () // помогает убрать пробелы в выражении

trimLeft // Помогает убрать пробелы слева

trimRight // Помогает убрать пробелв

conteins // Содержится ли данное слово/выр-е в строке

Массивы Продвинуто
==================

* Массив это объект

* В массивах могут содержаться строки, булевые значения и числа

const Banana = ['яблоко', 'морковь', 'редька', `репа`, true, 151];

* Можно создавать массив через конструкцию new Array ()

* Прототипы - это набор взаимосвязанных объектов, благодаря которым мы можем добавить новый функционал.

`название переменной (объекта)`.push () // Добавить в конец массива новый элемент. 

* .push метод, потому что мы вызывем его у конкретного объекта

`название переменной (объекта)`.unshift () // Добавить в начало массива новый элемент.

Пример:

const Banana = ['яблоко', 'морковь', 'редька', `репа`, true, 151];

Banana.push(1523)
Banana.unshift(`мандрагора`)

console.log(Banana) => ['мандрагора', 'яблоко', 'морковь', 'редька', 'репа', true, 151, 1523]

`название переменной (объекта)`.shift (сюда можно не писать ничего) // Убрать элемент из начала массива

`название переменной (объекта)`.pop (сюда можно не писать ничего) // Убрать элемент из конца массива

`название переменной (объекта)`.reverse (сюда можно не писать ничего) // Переворачивает массив, т.е. первое становится последним и наоборот: [151, true, 'репа', 'редька', 'морковь', 'яблоко']

Задача 1: Написать фразу наоборот
---------------------------------

const text = `Убрать элемент из начала массива`

const text2 = text.split (``).reverse().join(``)

console.log(text2) => ависсам алачан зи тнемелэ ьтарбУ

Пояснение:

`название переменной (объекта)`.split // Переводим что-то в массив. Счёт элементов (индексов) начинется с нуля. 

const text2 = text.split () // Если скобки пустые, то массив будет состоять из всех букв этой строчки.

const text2 = text.split (`из`) // Убирает из фразы "из" и делит её на два элемента: (2) ['Убрать элемент ', ' начала массива']

reverse() // Переворачивает фразу

join(``) // Объединяет элементы массива в строчку - по умолчанию ч/з запятую, но тут мы заменили на ``, поэтому будет пробел

Как изменить один элемент массива?
----------------------------------

const Banana = ['яблоко', 'морковь', 'редька', `репа`, true, 151]

const index = Banana.indexOf(`редька`) // Выделяем элемент, узнаем его индекс

Banana[index] = `potato` // Заменяем его 

console.log(Banana)

=> ['яблоко', 'морковь', 'potato', 'репа', true, 151]

includes
--------

* метод, который покажет включает ли массив в себя тот или иной объект

const Banana = ['яблоко', 'морковь', 'редька', `репа`, true, 151]

console.log(Banana.includes ('морковь')) // true

.findIndex
----------

const actress = [
    {name: `Eva`, tits: 3},
    {name: `Alisa`, tits: 5},
    {name: `Kristina`, tits: 1},
]

const index1 = actress.findIndex (function (person) {
    console.log(person)
})

// {name: 'Eva', tits: 3}
// {name: 'Alisa', tits: 5}
// {name: 'Kristina', tits: 1} // .findIndex циклами совершает итерации

Метод .map
---------

// Преобразование данных.

// Метод map возвращает в консольлоге новый массив. С помощью него мы можем изменять объекты массива, не меняя его, потому что создаеётся новый массив. 

const Banana = ['яблоко', 'морковь', 'редька', `репа`]

const bigFriuts = Banana.map(fruit => { // Необходимо создать новую переменную
    return fruit.toUpperCase()
})

console.log(bigFriuts) // ['ЯБЛОКО', 'МОРКОВЬ', 'РЕДЬКА', 'РЕПА']

// Возвести все числа массива во вторую степень:

const Banana1 = [150, 56, 11, 10]

const bigFriuts1 = Banana1.map(fruit1 => fruit1 ** 2)

console.log(bigFriuts1) // [22500, 3136, 121, 100]

// Как можно все сделать красивее?

const fib = [1, 1, 2, 3, 5, 8, 13]

const pow2 = num => num ** 2
const sqrt = num => Math.sqrt(num)

const pow2Fib = fib.map(pow2).map(Math.sqrt) // Мы ввели и вывели числа из квадратного корян
console.log(pow2Fib)

Метод .filter
-------------

* Как и map, возвращает новый массив, где данные изменены согласно опр-м условиям.

const Banana1 = [150, 56, 11, 15, 110, 1]

const bigFriuts1 = Banana1.map(fruit1 => fruit1 ** 2)

const FiltrBigFriuts1 = Banana1.filter(BigFriut => BigFriut > 100) //Вводим новую функцию, с помощью которой задаём условие. Тут ретёрн не по умолчанию, поэтому  не надо писать.

// !Необходимо обязательно вводить новую переменную, иначе не будет прведена фильрация

console.log(FiltrBigFriuts1) // [150, 110]

Как найти конкретного человека?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

const index1 = actress.findIndex (function (person) { // Тут ищем индекс объекта
})
    return person.tits === 3 

console.log(index1) // Выйдет 0, потому что у {name: `Eva`, tits: 3} нулевой индекс в массиве

const index2 = actress.find (function (person) { // Тут просто ищем объект
    return person.tits === 3 
})

console.log(index2) // Выйдет {name: 'Eva', tits: 3}. 

Как записать действие выше короче?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

const index2 = actress.find (person => person.tits === 3)
console.log(index2) // Вместо функции стрелочка. Слово ретёрн не нужно, потому что выражение однострочное.

Как реализовать поиск конкретного объекта через цикл?
----------------------------------------------------

// Циклы - простой способ сделать какое-то действие несколько раз. 

// Цикл for повторяет действия, пока не произойдёт какое-либо специальное событие завершения цикла. Оператор for в JavaScript аналогичен оператору for в Java и C. Объявление оператора for выглядит следующим образом:

// for ([начало]; [условие]; [шаг]) выражения

const actress = [
    {name: `Eva`, tits: 3},
    {name: `Alisa`, tits: 5},
    {name: `Kristina`, tits: 1},
]

for (const person of actress) {
    console.log(person)
}
// В косоли:
// {name: 'Eva', tits: 3}
// {name: 'Alisa', tits: 5}
// {name: 'Kristina', tits: 1}

let SizeTits
for (const person of actress) {
    if (person.tits === 3) {
        SizeTits = person
    }
}

console.log(SizeTits) // {name: 'Eva', tits: 3}

Метод .reduce
-------------

// Метод reduce() применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.

// Суммирует данные в массиве.
// Первым параметром он принимает в себя функцию, а вторым значение от которого будем считать.
// Функция примает в себя аккумулятор (acc), который будет обновляться при каждой итерации в массиве, и элемент по которому будет проходить итерация => ВСЕГО ДВА ЭЛЕМ_ТА ВНУТРИ Ф-ЦИИ

const actress = [
    {name: `Eva`, royalty: 4500},
    {name: `Alisa`, royalty: 5180},
    {name: `Kristina`, royalty: 2300},
]

const actressRoyalty = actress.reduce (function (acc, person){
    acc += person.royalty // Мы тут присваиваем к acc person.royalty
    return acc
}, 0)

console.log(actressRoyalty) // 11980

// !Чейнинг - когда мы подряд вызываем несколько методов.

const actressRoyalty = actress
.filter (person => person.royalty > 2500) //Фильтр вызывает новый массив. А метод reduce его меняет.
.reduce ((acc, person) => {
    acc += person.royalty
    return acc
}, 0) 

console.log(actressRoyalty) // 9680

Ассинхронность
==============

// Чтобы выполнить код, нам нужен JavaScript Engine (движок) — программа, которая «читает и выполняет» то, что мы написали. Самый распространённый движок среди всех — это V8, он используется в Google Chrome и Node.js.

// Выполнение JS-кода — однопоточное. Это значит, что в конкретный момент времени движок может выполнять не более одной строки кода. То есть вторая строка не будет выполнена, пока не выполнится первая.

// Такое выполнение кода (строка за строкой) называется синхронным.

Ассинхронные функции
--------------------

setTimeout () // Функция, которая отвечает за вызов функции или выполнение фрагмента кода после указанной задержки.

// Принимает в себя два параметра один из которых обязательный: колбэк функцию и отрезок времени в милисикундах (1 сек = 1000 милисек). 

const timeout = setTimeout(() => {
    console.log('After timeout')
    }, 2500)

clearTimeout (название констаны с функцией) // Отменить дей-е функции setTimeout

setInterval / clearInterval // Одно и то же сообщение будет выводиться с заданным интервалом.

Промисы
-------

// Созданы, чтобы убрать большое нагромождение кода

// Интерфейс Promise (промис) представляет собой обёртку для значения, неизвестного на момент создания промиса. Он позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными: вместо конечного результата асинхронного метода возвращается своего рода обещание (дословный перевод слова "промис") получить результат в некоторый момент в будущем.

// Promise может находиться в трёх состояниях:

// * ожидание (pending): начальное состояние, не исполнен и не отклонён.
// * исполнено (fulfilled): операция завершена успешно.
// * отклонено (rejected): операция завершена с ошибкой.

// При создании промис находится в ожидании (pending), а затем может стать исполненным (fulfilled), вернув полученный результат (значение), или отклонённым (rejected), вернув причину отказа. В любом из этих случаев вызывается обработчик, прикреплённый к промису методом then. (Если в момент назначения обработчика промис уже исполнен или отклонён, обработчик всё равно будет вызван, т.е. асинхронное исполнение промиса и назначение обработчика не будет происходить в «состоянии гонки», как, например, в случае с событиями в DOM.)

// Объект функции с двумя аргументами resolve и reject. Функция executor получает оба аргумента и выполняется сразу, ещё до того как конструктор вернёт созданный объект. Первый аргумент (resolve) вызывает успешное исполнение промиса, второй (reject) отклоняет его. Обычно функция executor описывает выполнение какой-то асинхронной работы, по завершении которой необходимо вызвать функцию resolve или reject. Обратите внимание, что возвращаемое значение функции executor игнорируется.

// executor колбек функция внутри промиса, resolve = всё хорошо, reject = произошла ошибка.

// Метод Promise.resolve(value) возвращает Promise выполненный с переданным значением. value - это любое значение, включая текст

const delay = (wait = 1000) => {
    const promise = new Promise((resolve, reject) => {
      setTimeout(() => {
        // resolve() 
        reject('Что-то пошло не так. Повторите попытку')

        // ВАЖНО: resolve идёт перед reject
      }, wait)
    })
    return promise
  }

delay(2500)
  .then(() => {
       console.log('After 2 seconds')
  })
  .catch(err => console.error('Error:', err)) // работает только в случае отклонения промиса.
  .finally(() => console.log('Finally')) // Метод finally() возвращает Promise. Когда промис был выполнен, вне зависимости успешно или с ошибкой, указанная функция будет выполнена. Это даёт возможность запустить один раз определённый участок кода, который должен выполниться вне зависимости от того, с каким результатом выполнился Promise.

const getData = () => new Promise(resolve => resolve([
    1, 1, 2, 3, 5, 8, 13
  ])) // Можно записать промис и так

async function asyncExample() { // C помощью async можно сделать функцию асинхронной
    try { // опеартор try catch
      await delay(3000)
      const data = await getData() // Оператор await заставляет функцию, объявленную с использованием оператора async, ждать выполнения Promise и продолжать выполнение после возвращения Promise значения. Впоследствии возвращает полученное из Promise значение. 
      console.log('Data', data)
    } catch (e) {
      console.log(e)
    } finally {
      console.log('Finally') // Такой же файнали как и в промисах
    }
  }

Работа с DOM
============

// Во вкладке Elements находится DOM-дерево

// Команда document показывает DOM-дерево в console.log. 

// document и window - глобальные функции.

// Вызывая window и какую-то функцию мы вызываем ее в общем окне.

window.alert () // вызов окна

window.confirm () // вызов окна, с возможностью выбора

document.getElementById () // Найти элемент в DOM дереве

const heading = document.getElementById('hello')

console.dir (heading.textContent)

heading.textContent = `Hello Mir` //Поменять текст внутри id, который мы нашли шагом выше

heading.style.colour = `red` //Надпись станет красной

// Console.dir это способ посмотреть в консоли свойства заданного javascript объекта. Через неё можно искать нужные методы.

const heading = document.getElementById (`hel`)

// Чтобы работало необходимо внести изменения в html-файл: добавить айди и класс <h1 id="hello" class="heading">Hello World!</h1>.

setTimeout(() => {
    addStylesTo(heading) //Выполняем фукцию для константы выше
  }, 1500)

function addStylesTo(node, text, color = 'red', fontSize) { //Здесь цвет параметр по умолчанию, если мы его отдельно не задаём. Но если зададим отдельно в другой ф-ции, то цыет поменяется.
    node.textContent = text // Поменять текст
    node.style.color = color // Поменять цвет текста
    node.style.textAlign = 'center' //Поменять местоположение текста на экране
    node.style.backgroundColor = 'black' //Цвет фона
    node.style.padding = '2rem' // Добавить падинг. Свойство padding устанавливает внутренние отступы/поля со всех сторон элемента. Область отступов это пространство между содержанием элемента и его границей. Отрицательные значения не допускаются.
    node.style.display = 'block'
    node.style.width = '100%'
}

node. // Параметр, который мы передаём в функцию

// falsy значения: '', undefined, null, 0, false

// Мы можем менять текст для уже заданной функции. Как?

setTimeout(() => {
    addStylesTo(heading, `Всё будет хорошо!`) //Этот текст будет вместо того, что мы задали в функции 
  }, 1500)

Как поменять внешний вид текста без id?
---------------------------------------

<h2>This is heading 2</h2>

// Задаем надписи класс: <h2 id="sub-hello" class="h2-class">This is heading 2</h2>

//Теперь выполняем метод применимый к классу:

const heading2 = document.getElementsByClassName('h2-class')[0] // 0 это индекс искомого текста 
//Устаревший метод 

//Современный метод:

const heading2 = document.querySelector('.h2-class') //В скобрках пишем css селектор, наример, #sub-hello - id (пишется с решеткой), класс пишется с точкой вначале ('.h2-class'), по <h2> тоже можно искать.

// .querySelector возвращает всегда один элемент

// .querySelectorAll берет все теги, а не один. Возвращает их в консоли в форма массива.

Введение в браузерные события
=============================

Событие – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).

Вот список самых часто используемых DOM-событий, пока просто для ознакомления:

События мыши:

// click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
// contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.
// mouseover / mouseout – когда мышь наводится на / покидает элемент.
// mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
// mousemove – при движении мыши.
// События на элементах управления:

// submit – пользователь отправил форму <form>.
// focus – пользователь фокусируется на элементе, например нажимает на <input>.

Клавиатурные события:

// keydown и keyup – когда пользователь нажимает / отпускает клавишу.
// События документа:

// DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.

CSS events:

// transitionend – когда CSS-анимация завершена.

Есть три способа назначения обработчиков событий:

// Атрибут HTML: onclick="...".
// DOM-свойство: elem.onclick = function.
// Специальные методы: elem.addEventListener(event, handler[, phase]) для добавления, removeEventListener для удаления.
// HTML-атрибуты используются редко потому, что JavaScript в HTML-теге выглядит немного странно. К тому же много кода там не напишешь.

// DOM-свойства вполне можно использовать, но мы не можем назначить больше одного обработчика на один тип события. Во многих случаях с этим ограничением можно мириться.

// Последний способ самый гибкий, однако нужно писать больше всего кода. Есть несколько типов событий, которые работают только через него, к примеру transitionend и DOMContentLoaded. Также addEventListener поддерживает объекты в качестве обработчиков событий. В этом случае вызывается метод объекта handleEvent.

MouseEvent
----------

// Как заставить текст меняться по клику?

// Интерфейс MouseEvent представляет собой событие, которое происходит в результате взаимодействия пользователя с манипулятором ( например, мышью). Наиболее частые из таких событий: click (en-US), dblclick (en-US), mouseup (en-US), mousedown (en-US).

heading.onclick = () => { //Свойство onclick возвращает обработчик события click на текущем элементе.
    if (heading.style.color === 'red') { //Если мы кликаем по надписи она приобретает аткие параметры
      heading.style.color = '#000'
      heading.style.backgroundColor = '#fff'
    } else {
      heading.style.color = 'red' //В другом случае она остаётся такой же
      heading.style.backgroundColor = '#000'
    }
  }

// Другой способ:


heading2.addEventListener('dblclick', () => { //Добавляем условие (двойной клик) и функцию, что произойдёт прои этиом условии
    if (heading2.style.color === 'yellow') {
      heading2.style.color = '#000'
      heading2.style.backgroundColor = '#fff'
    } else {
      heading2.style.color = 'yellow'
      heading2.style.backgroundColor = '#000'
    }
  })


CSS
===

// px – абсолютные пиксели, к которым привязаны и потому не нужны mm, cm, pt и pc. Используется для максимально конкретного и точного задания размеров.

// em – задаёт размер относительно шрифта родителя, можно относительно конкретных символов: "x"(ex) и "0"(ch), используется там, где нужно упростить масштабирование компоненты.

// rem – задаёт размер относительно шрифта <html>, используется для удобства глобального масштабирования: элементы которые планируется масштабировать, задаются в rem, а JS меняет шрифт у <html>.

// % – относительно такого же свойства родителя (как правило, но не всегда), используется для ширин, высот и так далее, без него никуда, но надо знать, относительно чего он считает проценты.

// vw, vh, vmin, vmax – относительно размера экрана.

{
    Свойство: значение; //Всё это правило
    Свойство: значение;
    Свойство: значение;
}

h1 {
    color: blue;
}

// Как подключить стили на страницу?

<h1 style="color: blue">Всем привет! Я Вика</h1> //Неудобно

//Можно подключить через сторонний документ:

<link rel="stylesheet" //Вид, что это таблица стилей
href="style.css"> // Путь до файла

//Лучший вариант:

<style> h1 {

    font-family: Georgia, 'Times New Roman', Times, serif; //Тип шрифта: Основной, запасной, Особенности шрифта (с засечками или без)
    font-size: 64 px; //Размер шрифта 
    font-weight: bold; //Жирность шрифта
    color: blue;
    margin-bottom: 50 px //Отступ снизу
    margin-top: 50 px //Отступ сверху
    background-color: yellow; //Цвет фона
    border: 2px solid red; //Обводка фона и её цвет
    padding-top: 10px; //Внутренний отступ сверху
    padding-bottom: 10px; //Внутренний отступ снизу
    
} 
</style> //Пишется в head

body {

    font-family: 'Muli', sans-serif;
    overflow: hidden;
    margin: 0;
    background: #111;
    height: 100vh; // Здесь задаём всей странице один фон, который будет покрывать всю страницу
    display: flex; // Флекс-контейнер: элемент, к которому применяется свойство display: flex. Вложенные в него элементы подчиняются правилам раскладки флексов. Флекс-элемент: элемент, вложенный во флекс-контейнер. ТО что этоменты на экране можно перемещать.
    // Когда мы задаём какому-то элементу значение flex для свойства display, мы превращаем этот элемент в флекс-контейнер. Внутри него начинает действовать флекс-контекст, его дочерние элементы начинают подчиняться свойствам флексбокса.
    justify-content: center; // Выравнивание элементов по центру. Браузер сам выравнивает
    align-items: center;//CSS свойство align-items выравнивает flex-элементы текущей flex-линии таким же образом, как и justify-content, но в перпендикулярном направлении.
}


.container {
    width: 100%;
    display: flex;
    padding: 0 20px;
  } //  Контейнеры используются для размещения, вставки и (иногда) центрирования содержимого внутри них. 


//Можно задать параметры классу, который мы указали в html: class="slide"

.slide {
    height: 80vh; //Расположение на экране в %
    border-radius: 20px; // border-radius — это CSS-свойство, позволяющее разработчикам определять, как скругляются границы блока. Закруглённость каждого угла определяется с помощью одного или двух радиусов, определяя его форму: круг или эллипс.
    margin: 10px; //Расстояние между элементами. CSS свойство margin определяет внешний отступ на всех четырёх сторонах элемента.
    cursor: pointer; //Если навести курсор на элемент, то будет показано, что с ним можно что-то сделать
    color: #fff;
    flex: 1;
    // Свойство CSS flex - это сокращённое свойство, определяющее способность гибкого элемента растягиваться или сжиматься для заполнения собой доступного свободного пространства. Это свойство устанавливает flex-grow, flex-shrink и flex-basis.

//    Начальное значение как и у каждого из подсвойств этого свойства:
//    flex-grow: 0
//    flex-shrink: 1
//    flex-basis: auto

    background-size: cover; //Размер фона. cover - ключевое значение
    background-position: center; //Начальная позиция для фонового элемента
    background-repeat: no-repeat; //Будет ли повторяться изображение

    box-shadow:4px 4px 9px rgba(198, 198, 198, 0.36); //CSS-свойство box-shadow добавляет тень к элементу. Через запятую можно задать несколько теней. Тень описывается смещениями по оси X и Y относительно элемента, радиусом размытия и распространения, а также цветом.
}

Opacity
// CSS-свойство opacity устанавливает непрозрачность элемента. Непрозрачность - это степень, в которой содержимое скрывается за элементом, является противоположностью прозрачности. 0 - ничего не видно, 1 - видно всё. 

transition
// transition: transform 0.5s ease-in-out Заставляет двигаться свойство transform. Transition позволяет определять переходное состояние между двумя состояниями элемента.


Наследование
------------

//Задавая условия родительскому элементу, напр. body, мы задаем условия и элементам внутри него.

Адаптивная верстка
------------------

img {
    width: 100%; // Картинка подстраивается под размер экрана
    max-whidth: 300px; //Ограничение до какого размера может изменяться на экране картинка
}

// px не подстраивается под размер экрана, em и rem подстраиваются.

* px (пиксели): Количество пикселей в высоту, на которое вы хотите расположить текст. Это абсолютная единица измерения - она приводит к одному и тому же конечному вычисленному значению для шрифта на странице практически в любой ситуации.

* ems: 1 em равен размеру шрифта, установленному на родительском элементе текущего элемента, который мы стилизуем (точнее, ширине заглавной буквы M, содержащейся внутри родительского элемента). Это может оказаться сложным, если у вас много вложенных элементов с разными размерами шрифта, но это возможно, как вы увидите ниже. Почему? Это вполне естественно, когда вы привыкнете к этому, и вы можете использовать em для определения размера всего, а не только текста. Вы можете создать целый веб-сайт, используя em, что упрощает его обслуживание.

* rems: Они работают так же, как и em, за исключением того, что 1 rem равен размеру шрифта, установленному для корневого элемента документа (т.е. <html>), а не для родительского элемента. Это значительно упрощает математические вычисления для определения размера шрифта, хотя если вы хотите поддерживать действительно старые браузеры, вы можете столкнуться с трудностями - rem не поддерживается в Internet Explorer 8 и ниже.

div 
---- 

// Элемент разделения контента HTML (<div>) является универсальным контейнером для потокового контента. Он не влияет на контент или макет до тех пор, пока не будет стилизован с помощью CSS.

Импортировать шрифт
-------------------

@import url("https://fonts.googleapis.com/css?family=Roboto&display=swap");

Как сделать перетаскиваемые объекты
------------------------------------ 

//Свойство target интерфейса Event является ссылкой на объект, который был инициатором события. Он отличается от Event.currentTarget, если обработчик события вызывается во время всплытия (bubbling) или захвата события.

meta
----

Тег, который позволяет добавить описание к заголовку страницы. Описание будет отображаться в гугл при поиске. 

<meta name="description" content="Здесь пишеться непостредственно описание">

//ul - элемент списка с точками
//ol - список с цифрами
//margin - внешний отступ
//paddin - внутренний отступ

Строчные элменты
----------------

* На них не действует свойство Width и вертикальные отступы (margin)

* Внутри строчного элемента не может быть блочного элемента

shift + alt + a - Закоментирвать

* Про отсупы: Если отступ сверхк и снизу пересекаются, то браузер оставляет просто тот отступ, что больше 

Правила верстки
---------------

!!! Padding – это отступ от содержимого до края блока (внутри блока), margin – расстояние от одного блока до другого, межблоковое пространство. 

* Правильно использовать margin-right и margin-bottom, остальные марджины лучше стараться не сипользовать

* Элемент не может двигать сам себя, его может двигать только его сосед.

* Если нет соседнего элемента сверху или слева, мы используем padding top или padding left у родителя.

Псевдоклассы
""""""""""""
Нужны когда нужно изменить свойство элемента при наведении на него:

*Тег*:hover (Наведение) - Ховер тут псевдокласс

* last-child - свойства применяются только к последнему элменту

Добавление фонового изображения
------------------------------

!!! Тег <img> используется для изображений, которые являются чатью контента (логотип, иконки). 

background-image: url(../img/01-Картинка-фона.jpg); - свойство для указания пути до фонового изображения

../ - выход из папки

background-position - расположение изображения в контейнере

background-size - свойство для указания размера фонового изображения

* contain - подстравивается под размер контейнера (по высоте рамки)
* cover - покрывает весь контейнер (растягивалась по ширине)

background-repeat - повторение изображения на всё свободное место контейнера

background-attachment - настройка изображения при прокрутке страницы (редко используется)

Вместо свойств выше можно использовать просто background:

background: url(../img/01-Картинка-фона.jpg) center/cover no; (Сочетание свойств position и size пишется через слеш)

Position
---------

position: static - обычное поведение элемента (базовое значение)

relative - позволяет отталкивать элемент от других элементов или от родительского. 

Отодвигать с помощью top, bottom, screenLeft, right. Противоположные значения не должны использоваться вместе.

absolute - заставляет элемент отталкиваться от body, а не от других элементов, т.е. вырывает элемент из потока.
Не отталкивается от body, если у родительского элемента есть position: relative. 

!!! relative отталкивается от соседей, а absolute нет.

fixed - фиксирует элемент в заданном месте при прокрутке.

sticky - при прокрутке страницы до элемента, которому задан sticky, он закрепляется в заданной позиции.

Например: 

{
position: sticky;
top: 0px;
} - когда доведем до него курсор закрепиться на условии top: 0px;

Z-index
-------

Позволяет распологать элементы друг над другом или под друг другом.

Третье измерение. По умолчанию у всех элементов 0. 

Не работает сам по себе, а только с позиционированными элементами. 

Позволяет распологать элементы друг над другом или под друг другом.

!!! margin: 0 auto; - выровнять по центру. Работает только если у элемента есть width. Выравнивает посередине только по горизонтали. 

* {} - Применить ко всем тегам

Расчёт адаптивного отступа
--------------------------

* Высчитать сколько размер отступа в процентах от общего размера блока

Длина отступа (разделить на) длину блока * 100

Box-sizing 
----------

По умолчанию в блоковой модели CSS ширина и высота, которую вы задаёте элементу применяется только для контента элемента. Если у элемента есть граница или внутренний отступ, то они добавляются к ширине и высоте, чтобы получить отображаемый на экране размер. Это значит, что когда вы выставляете ширину и высоту, вам придётся изменять значение, при добавлении границ и отступов. Например, если у вас есть четыре блока с width: 25%; , и у какого-нибудь из них есть граница или внутренний отступ слева или справа, то по умолчанию они не поместятся на одной строке.

Свойство box-sizing может изменять это поведение:

content-box 

даёт стандартное поведение свойства box-sizing. Если вы выставите элементу ширину 100 пикселей, то ширина его контента будет 100 пикселей, а ширина границ и внутренних отступов при рендере будет добавлена к финальной ширине, делая элемент шире ста пикселей.

border-box 

говорит браузеру учитывать любые границы и внутренние отступы в значениях, которые вы указываете в ширине и высоте элемента. Если вы выставите элементу ширину 100 пикселей, то эти 100 пикселей будут включать в себя границы и внутренние отступы, а контент сожмётся, чтобы выделить для них место. Обычно это упрощает работу с размерами элементов.

**Примечание:**Часто выставление box-sizing: border-box полезно для размещения элементов. Оно сильно упрощает работу с размерами элементов, и как правило устраняет ряд подводных камней, на которые вы можете наткнуться, размещая контент. С другой стороны, используя position-relative или position: absolute, box-sizing: content-box позволяет позиционным значениям быть зависимыми только от контента, а не от границ и отступов, что иногда желательно.

API
----

* Обращение клиента к стороннему сервису

API (Application programming interface) — это контракт, который предоставляет программа. «Ко мне можно обращаться так и так, я обязуюсь делать то и это».

Контракт включает в себя:
саму операцию, которую мы можем выполнить,
данные, которые поступают на вход,
данные, которые оказываются на выходе (контент данных или сообщение об ошибке).

Вызвать API можно как напрямую, так и косвенно:
Система вызывает функции внутри себя
Система вызывает метод другой системы
Человек вызывает метод
Автотесты дергают методы
Пользователь работает с GUI

Когда говорят про API с тестировщиком, обсуждают два варианта:
автотесты на уровне API (умение автоматизировать)
интеграцию между двумя разными системами (обычно SOAP или REST, то есть работу в SOAP Ui или Postman).

На собес
========

Почему JavaScript функции являются объектами первого класса (First-class Objects)?
=================================================================================

Объект первого класса (first class object или first class citizen) это объект, который может быть передан как аргумент функции, возвращён из функции или присвоен переменной.

Функции в JavaScript полностью соответствуют этому определению.

Функцию можно присвоить переменной:

const multipleTwo = (n) => n * 2;


Функция может быть передаваемым аргументом другой функции:

async function loadData(func) {
  loading = true;
  // другой код относящийся к инициализации статусов загрузки

  await func();

  loading = false;
  // другой код относящийся к обработке статуса загрузки
}

function getData() {
  // код получения данных с сервера
}

loadData(getData);

Функции могут быть возвращаемым значением другой функции:

function makeAdder(x) {
  return function(y) {
    return x + y;
  };
};

Что такое IIFE?
=================

IIFE (Immediately Invoked Function Expression) – это функция, которая выполняется сразу же после того, как была определена.

Записывается так:

(function () {
    // какие-то действия
})();


IIFE состоит из двух частей:

Функция с лексической областью видимости, заключённая в круглые скобки
Мгновенно выполняющееся функциональное выражение ()
Функция внутри скобок создаёт внутри себя область видимости, доступ к которой есть только у неё. Всё, что внутри функции, остаётся только внутри.

Примеры использования: Скопировать ссылку "Примеры использования:"
Используя IIFE, можно не бояться конфликтов имён переменных.

(function () {
    let name = "Дока Дог";
    console.log(name);
})();

(function () {
    let name = "Гав-Гав";
    alert(name);
})();

// Никаких конфликтов


Также переменная, которой присвоено значение IIFE, хранит в себе результат выполнения функции, но не саму функцию.

let result = (function () {
    let name = "Дока Дог";
    return name;
})();

console.log(result); //Дока Дог

Часто вам могут задать такой вопрос: Скопировать ссылку "Часто вам могут задать такой вопрос:"
Является ли это IIFE?

function(){}(); - Нет